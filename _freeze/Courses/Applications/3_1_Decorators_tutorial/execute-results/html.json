{
  "hash": "826f74ed01068818f0f886f058ef21ff",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Decorators Tutorial\n---\n\n\n\n\n## Decorators\n\nDecorators are a way to modify or extend the behavior of functions or methods. They are a form of metaprogramming and can be used to add functionality to existing functions or methods without modifying their code. Decorators are a powerful tool in Python and are widely used in libraries and frameworks.\n\nIn Python, decorators are implemented using the `@` symbol followed by the decorator function name. Decorators can be used to add functionality such as logging, timing, caching, access control, and more to functions or methods.\n\nIn this tutorial, we will explore how decorators work and how to create and use them in Python.\n\n## Creating a Decorator\n\nTo create a decorator, we define a function that takes another function as an argument and returns a new function that wraps the original function. The new function can modify the behavior of the original function by adding additional functionality before or after it is called.\n\nHere is an example of a simple decorator that prints a message before and after calling a function:\n\n::: {#e6f0a10d .cell execution_count=1}\n``` {.python .cell-code}\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before calling the function\")\n        func()\n        print(\"After calling the function\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello, world!\")\n\nsay_hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore calling the function\nHello, world!\nAfter calling the function\n```\n:::\n:::\n\n\nIn this example, the `my_decorator` function takes a function `func` as an argument and returns a new function `wrapper` that prints a message before and after calling the original function. The `@my_decorator` syntax is used to apply the decorator to the `say_hello` function.\n\n## Decorator with Arguments\n\nDecorators can also take arguments to customize their behavior. To create a decorator with arguments, we need to define a function that returns a decorator function. The decorator function then takes the original function as an argument and returns a new function that wraps the original function.\n\nHere is an example of a decorator with arguments that prints a message with a custom prefix before and after calling a function:\n\n::: {#7b0d5556 .cell execution_count=2}\n``` {.python .cell-code}\ndef prefix_decorator(prefix):\n    def decorator(func):\n        def wrapper():\n            print(f\"{prefix}: Before calling the function\")\n            func()\n            print(f\"{prefix}: After calling the function\")\n        return wrapper\n    return decorator\n\n@prefix_decorator(\"INFO\")\ndef say_hello():\n    print(\"Hello, world!\")\n\nsay_hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nINFO: Before calling the function\nHello, world!\nINFO: After calling the function\n```\n:::\n:::\n\n\nIn this example, the `prefix_decorator` function takes an argument `prefix` and returns a decorator function that prints a message with the specified prefix. The `@prefix_decorator(\"INFO\")` syntax is used to apply the decorator with the prefix \"INFO\" to the `say_hello` function.\n\n## Decorator Classes\n\nDecorators can also be implemented using classes. To create a decorator class, we define a class with a `__call__` method that takes the original function as an argument and returns a new function that wraps the original function.\n\nHere is an example of a decorator implemented as a class that prints\na message before and after calling a function:\n\n::: {#4adae7a9 .cell execution_count=3}\n``` {.python .cell-code}\nclass MyDecorator:\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self):\n        print(\"Before calling the function\")\n        self.func()\n        print(\"After calling the function\")\n\n@MyDecorator\ndef say_hello():\n    print(\"Hello, world!\")\n\nsay_hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore calling the function\nHello, world!\nAfter calling the function\n```\n:::\n:::\n\n\nIn this example, the `MyDecorator` class defines an `__init__` method that takes the original function `func` as an argument and an `__call__` method that wraps the original function. The `@MyDecorator` syntax is used to apply the decorator to the `say_hello` function.\n\n## Conclusion\n\nDecorators are a powerful feature in Python that allow us to modify or extend the behavior of functions or methods. They are widely used in Python libraries and frameworks to add functionality such as logging, timing, caching, access control, and more. By understanding how decorators work and how to create and use them, we can write more flexible and reusable code in Python.\n\nIn this tutorial, we explored how to create decorators, how to create decorators with arguments, and how to create decorators using classes. We also discussed some common use cases for decorators and how they can be used to add functionality to existing functions or methods.\n\nDecorators are a versatile tool in Python and can be used to solve a wide range of problems. By mastering decorators, we can write more concise, readable, and maintainable code in Python.\n\n## References\n\n- [Python Decorators](https://docs.python.org/3/glossary.html#term-decorator)\n- [Real Python - Primer on Python Decorators](https://realpython.com/primer-on-python-decorators/)\n- [Python Wiki - Python Decorators](https://wiki.python.org/moin/PythonDecorators)\n- [Python Decorator Library](https://wiki.python.org/moin/PythonDecoratorLibrary)\n- [Python Decorator Tutorial](https://www.datacamp.com/community/tutorials/decorators-python)\n- [Python Decorator Examples](https://www.programiz.com/python-programming/decorator)\n- [Python Decorator Patterns](https://python-patterns.guide/gang-of-four/decorator-pattern/)\n- [Python Decorator Design Patterns](https://refactoring.guru/design-patterns/decorator/python/example)\n- [Python Decorator Cookbook](https://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html)\n- [Python Decorator Recipes](https://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html#recipes)\n\n",
    "supporting": [
      "3_1_Decorators_tutorial_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}