{
  "hash": "6b01090c8aad5f6695f7158fdf4b7164",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An `asyncio` application\"\n---\n\n\n\n\n## Simple *Hello world* example\n\nJust make an asyncio coroutine which displays *Hello* and *world* with a 1 second delay in between and then await it.\n\n::: {#bbbc56f6 .cell tags='[\"solution\"]' execution_count=2}\n``` {.python .cell-code}\nimport asyncio\n\n\nasync def hello():\n    print(\"Hello\")\n    await asyncio.sleep(1)\n    print(\"world\")\n\n\nawait hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nworld\n```\n:::\n:::\n\n\n## `asyncio` queues\n\n[Official doc](https://docs.python.org/3/library/asyncio-queue.html)\n\n> asyncio queues are designed to be similar to classes of the queue module. Although asyncio queues are not thread-safe, they are designed to be used specifically in async/await code.\n> Note that methods of asyncio queues don’t have a timeout parameter; use asyncio.wait_for() function to do queue operations with a timeout.\n\nwe have `put`/`get` coroutines for the queue.\n\n## `asyncio` queues example\n\n::: {#bcaaca86 .cell execution_count=3}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nawait queue.put(1)\nawait queue.put(2)\n\nprint(await queue.get())\nprint(await queue.get())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n```\n:::\n:::\n\n\n# Producer/Consumer example\n\n![](../figs/producer-consumer.png)\n\n- We want to produce, asynchronously, a sequence of integers and consume them as they are produced, also asynchronously.\n- Producing and consuming are two separate tasks, communicating through a queue.\n- We’ll arbitrarily slow down the producer by sleeping 1 second for each produced item.\n\nThe producer, once finished will produce a `None` in the queue, so that the consumer knows it’s done.\n\n## Pure `asyncio` solution\n\n::: {#748c6287 .cell execution_count=4}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nasync def produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\n\nasync def consume():\n    print(\"consuming items\")\n    consumed = 0\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nres = . . .\nres\n```\n:::\n\n\n::: {#5515f28d .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nasync def produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        await asyncio.sleep(1)\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        await queue.put(item)\n\n    # indicate the producer is done\n    await queue.put(None)\n    return n\n\n\nasync def consume():\n    print(\"consuming items\")\n    consumed = 0\n    while True:\n        # wait for an item from the producer\n        item = await queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        print(\"consuming {}\".format(item))\n        # simulate i/o operation using sleep\n        consumed += 1\n    return consumed\n\nres = await asyncio.gather(\n    produce(10),\n    consume()\n)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## The same with threads\n\n:::{.callout-caution }\nThreads doesn’t run coroutines directly. We need to use [`run_coroutine_threadsafe(coroutine,loop)`](https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe) to run a coroutine in a thread, dispatching it to the event loop. It returns a `Future` object that we can use to wait for the result of the coroutine.\n:::\n\nFor thread-safe queues, we can use the `queue` module from the standard library (not `asyncio.Queue`).\n\n::: {#7e5bc1fb .cell execution_count=6}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\nfrom queue import Queue\n\nqueue = Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\ndef consume():\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ThreadPoolExecutor() as pool:\n    res = . . .\nres\n```\n:::\n\n\n::: {#1b89efb6 .cell tags='[\"solution\"]' execution_count=7}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\nfrom queue import Queue\n\nqueue = Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        future = asyncio.run_coroutine_threadsafe(asyncio.sleep(1), loop)\n        future.result()\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        queue.put(item)\n\n    # indicate the producer is done\n    queue.put(None)\n    return n\n\ndef consume():\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        item = queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ThreadPoolExecutor() as pool:\n    res = await asyncio.gather(\n        loop.run_in_executor(pool, functools.partial(produce, 10)),\n        loop.run_in_executor(pool, functools.partial(consume))\n    )\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## The same with processes\n\nThe queue is now a `multiprocessing.Queue`.\n\nFirst do it normally, like previous example, observe the output.\n    \nThen add a `Lock` to protect the `print` statements.\n\nThe sleep is now a Python `sleep` (not `asyncio.sleep`).\n\n```python\n#| eval: false\nlock = Lock()\n\n# inside a task\nwith lock:\n    print(\"foo bar\")\n```\n\n::: {#2fc92432 .cell execution_count=8}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ProcessPoolExecutor\nimport asyncio\nfrom multiprocessing import Manager, Lock\nfrom time import sleep\n\nmanager = Manager()\nqueue = manager.Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(queue, n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\n\ndef consume(queue):\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ProcessPoolExecutor() as pool:\n    res = . . .\nres\n```\n:::\n\n\n::: {#3be95bf6 .cell tags='[\"solution\"]' execution_count=9}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ProcessPoolExecutor\nimport asyncio\nfrom multiprocessing import Manager, Lock\nfrom time import sleep\n\nmanager = Manager()\nqueue = manager.Queue()\nloop = asyncio.get_running_loop()\nlock = Lock()\n\ndef produce(queue, n):\n    with lock:\n        print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        sleep(1)\n        # produce an item\n        with lock:\n            print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        queue.put(item)\n\n    # indicate the producer is done\n    queue.put(None)\n    return n\n\n\ndef consume(queue):\n    consumed = 0\n    with lock:\n        print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        item = queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        with lock:\n            print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ProcessPoolExecutor() as pool:\n    res = await asyncio.gather(\n        loop.run_in_executor(pool, functools.partial(produce, queue, 10)),\n        loop.run_in_executor(pool, functools.partial(consume, queue))\n    )\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## Exception Handling\n\n**See also**\n\n* [set_exception_handler](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.set_exception_handler)\n\n\n```python\ndef main():\n    loop = asyncio.get_event_loop()\n    # May want to catch other signals too\n    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)\n    for s in signals:\n        loop.add_signal_handler(\n            s, lambda s=s: asyncio.create_task(shutdown(loop, signal=s))\n        )\n    loop.set_exception_handler(handle_exception)\n    queue = asyncio.Queue()\n```\n\n## Testing with `pytest`\n\n### Example:\n\n```python\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_consume(mock_get, mock_queue, message, create_mock_coro):\n    mock_get.side_effect = [message, Exception(\"break while loop\")]\n\n    with pytest.raises(Exception, match=\"break while loop\"):\n        await consume(mock_queue)\n```\n\n### Third-party libraries\n\n* [pytest-asyncio](https://github.com/pytest-dev/pytest-asyncio) has helpfull things like fixtures for `event_loop`, `unused_tcp_port`, and `unused_tcp_port_factory`; and the ability to create your own [asynchronous fixtures](https://github.com/pytest-dev/pytest-asyncio/#async-fixtures).\n* [asynctest](https://asynctest.readthedocs.io/en/latest/index.html) has helpful tooling, including coroutine mocks and [exhaust_callbacks](https://asynctest.readthedocs.io/en/latest/asynctest.helpers.html#asynctest.helpers.exhaust_callbacks) so we don’t have to manually await tasks.\n* [aiohttp](https://docs.aiohttp.org/en/stable/) has some really nice built-in test utilities.\n\n## Debugging\n\n`asyncio` already has a [debug mode](https://docs.python.org/3.6/library/asyncio-dev.html#debug-mode-of-asyncio) in the standard library. You can simply activate it with the `PYTHONASYNCIODEBUG` environment variable or in the code with `loop.set_debug(True)`.\n\n### Using the debug mode to identify slow async calls\n\n`asyncio`’s debug mode has a tiny built-in profiler. When debug mode is on, `asyncio` will log any asynchronous calls that take longer than 100 milliseconds.\n\n### Debugging in oroduction with `aiodebug`\n\n[aiodebug](https://github.com/qntln/aiodebug) is a tiny library for monitoring and testing asyncio programs.\n\n#### Example\n\n```python\nfrom aiodebug import log_slow_callbacks\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    log_slow_callbacks.enable(0.05)\n```\n\n## Logging\n\n[aiologger](https://github.com/b2wdigital/aiologger) allows non-blocking logging.\n\n## Asynchronous Widgets\n\n**See also**\n\n* [Asynchronous Widgets](https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Asynchronous.html)\n\n::: {#e02b388d .cell execution_count=10}\n``` {.python .cell-code}\ndef wait_for_change(widget, value):\n    future = asyncio.Future()\n\n    def getvalue(change):\n        # make the new value available\n        future.set_result(change.new)\n        widget.unobserve(getvalue, value)\n\n    widget.observe(getvalue, value)\n    return future\n```\n:::\n\n\n::: {#244767f0 .cell execution_count=11}\n``` {.python .cell-code}\nfrom ipywidgets import IntSlider\n\n\nslider = IntSlider()\n\n\nasync def f():\n    for i in range(10):\n        print(\"did work %s\" % i)\n        x = await wait_for_change(slider, \"value\")\n        print(\"async function continued with value %s\" % x)\n\n\nasyncio.create_task(f())\n\nslider\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"c4a38d30dcbc44f59aca8c42712be01d\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "3_Asynchronous_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script src=\"https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js\" crossorigin=\"anonymous\"></script>\n"
      ],
      "include-after-body": [
        "<script type=application/vnd.jupyter.widget-state+json>\n{\"state\":{\"5d3752984e184b0f93cb43402b54d4c6\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"SliderStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"SliderStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"description_width\":\"\",\"handle_color\":null}},\"b81865dd839c4227b8adb49db54a475f\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"c4a38d30dcbc44f59aca8c42712be01d\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"IntSliderModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"IntSliderModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"IntSliderView\",\"behavior\":\"drag-tap\",\"continuous_update\":true,\"description\":\"\",\"description_allow_html\":false,\"disabled\":false,\"layout\":\"IPY_MODEL_b81865dd839c4227b8adb49db54a475f\",\"max\":100,\"min\":0,\"orientation\":\"horizontal\",\"readout\":true,\"readout_format\":\"d\",\"step\":1,\"style\":\"IPY_MODEL_5d3752984e184b0f93cb43402b54d4c6\",\"tabbable\":null,\"tooltip\":null,\"value\":0}}},\"version_major\":2,\"version_minor\":0}\n</script>\n"
      ]
    }
  }
}