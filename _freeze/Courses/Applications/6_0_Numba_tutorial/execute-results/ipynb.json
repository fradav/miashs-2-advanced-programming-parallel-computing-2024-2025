{
  "hash": "d15709d083696ad2917d7ff56aebf2a2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Numba Introduction\n---\n\n\n# Numba Basics\n\nNumba is a just-in-time compiler of Python functions.  It translates a Python function when it is called into a machine code equivalent that runs anywhere from 2x (simple NumPy operations) to 100x (complex Python loops) faster.  In this notebook, we show some basic examples of using Numba.\n\n::: {#f0bf1aee .cell slideshow='{\"slide_type\":\"-\"}' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport numba\nfrom numba import jit\n```\n:::\n\n\nLet's check which version of Numba we have:\n\n::: {#d91f3157 .cell slideshow='{\"slide_type\":\"-\"}' execution_count=2}\n``` {.python .cell-code}\nprint(numba.__version__)\n```\n:::\n\n\nNumba uses Python *decorators* to transform Python functions into functions that compile themselves.  The most common Numba decorator is `@jit`, which creates a normal function for execution on the CPU.\n\nNumba works best on numerical functions that make use of NumPy arrays.  Here's an example:\n\n::: {#62e62f18 .cell cell_style='center' slideshow='{\"slide_type\":\"fragment\"}' execution_count=3}\n``` {.python .cell-code}\n@jit(nopython=True)\ndef go_fast(a): # Function is compiled to machine code when called the first time\n    trace = 0.0\n    # assuming square input matrix\n    for i in range(a.shape[0]):   # Numba likes loops\n        trace += np.tanh(a[i, i]) # Numba likes NumPy functions\n    return a + trace              # Numba likes NumPy broadcasting\n```\n:::\n\n\nThe `nopython=True` option requires that the function be fully compiled (so that the Python interpreter calls are completely removed), otherwise an exception is raised.  These exceptions usually indicate places in the function that need to be modified in order to achieve better-than-Python performance.  We strongly recommend always using `nopython=True`.\n\nThe function has not yet been compiled.  To do that, we need to call the function:\n\n::: {#ae677362 .cell slideshow='{\"slide_type\":\"-\"}' execution_count=4}\n``` {.python .cell-code}\nx = np.arange(100).reshape(10, 10)\ngo_fast(x)\n```\n:::\n\n\nThis first time the function was called, a new version of the function was compiled and executed.  If we call it again, the previously generated function executions without another compilation step.\n\n::: {#8cc51c95 .cell slideshow='{\"slide_type\":\"-\"}' execution_count=5}\n``` {.python .cell-code}\ngo_fast(2*x)\n```\n:::\n\n\nTo benchmark Numba-compiled functions, it is important to time them without including the compilation step, since the compilation of a given function will only happen once for each set of input types, but the function will be called many times.\n\nIn a notebook, the `%timeit` magic function is the best to use because it runs the function many times in a loop to get a more accurate estimate of the execution time of short functions.\n\n::: {#3ff7b217 .cell slideshow='{\"slide_type\":\"-\"}' execution_count=6}\n``` {.python .cell-code}\n%timeit go_fast(x)\n```\n:::\n\n\nLet's compare to the uncompiled function.  Numba-compiled function have a special `.py_func` attribute which is the original uncompiled Python function.  We should first verify we get the same results:\n\n::: {#d6e60b6e .cell slideshow='{\"slide_type\":\"-\"}' execution_count=7}\n``` {.python .cell-code}\nprint(np.testing.assert_array_equal(go_fast(x), go_fast.py_func(x)))\n```\n:::\n\n\nAnd test the speed of the Python version:\n\n::: {#ca90dd7a .cell slideshow='{\"slide_type\":\"-\"}' execution_count=8}\n``` {.python .cell-code}\n%timeit go_fast.py_func(x)\n```\n:::\n\n\nThe original Python function is more than 20x slower than the Numba-compiled version.  However, the Numba function used explicit loops, which are very fast in Numba and not very fast in Python.  Our example function is so simple, we can create an alternate version of `go_fast` using only NumPy array expressions:\n\n::: {#5a858b4b .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=9}\n``` {.python .cell-code}\ndef go_numpy(a):\n    return a + np.tanh(np.diagonal(a)).sum()\n```\n:::\n\n\n::: {#13c009f9 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=10}\n``` {.python .cell-code}\nnp.testing.assert_array_equal(go_numpy(x), go_fast(x))\n```\n:::\n\n\n::: {#2aed5985 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=11}\n``` {.python .cell-code}\n%timeit go_numpy(x)\n```\n:::\n\n\nThe NumPy version is more than 2x faster than Python, but still 10x slower than Numba.\n\n### Supported Python Features\n\nNumba works best when used with NumPy arrays, but Numba also supports other data types out of the box:\n\n* `int`, `float`\n* `tuple`, `namedtuple`\n* `list` (with some restrictions)\n* ... and others.  See the [Reference Manual](https://numba.pydata.org/numba-doc/latest/reference/pysupported.html) for more details.\n\nIn particular, tuples are useful for returning multiple values from functions:\n\n::: {#bb6a3e34 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=12}\n``` {.python .cell-code}\nimport random\n\n@jit(nopython=True)\ndef spherical_to_cartesian(r, theta, phi):\n    '''Convert spherical coordinates (physics convention) to cartesian coordinates'''\n    sin_theta = np.sin(theta)\n    x = r * sin_theta * np.cos(phi)\n    y = r * sin_theta * np.sin(phi)\n    z = r * np.cos(theta)\n    \n    return x, y, z # return a tuple\n```\n:::\n\n\n::: {#57473371 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=13}\n``` {.python .cell-code}\n@jit(nopython=True)\ndef random_directions(n, r):\n    '''Return ``n`` 3-vectors in random directions with radius ``r``'''\n    out = np.empty(shape=(n,3), dtype=np.float64)\n    \n    for i in range(n):\n        # Pick directions randomly in solid angle\n        phi = random.uniform(0, 2*np.pi)\n        theta = np.arccos(random.uniform(-1, 1))\n        # unpack a tuple\n        x, y, z = spherical_to_cartesian(r, theta, phi)\n        out[i] = x, y, z\n    \n    return out\n```\n:::\n\n\n::: {#f9f264e3 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=14}\n``` {.python .cell-code}\nrandom_directions(10, 1.0)\n```\n:::\n\n\nWhen Numba is translating Python to machine code, it uses the [LLVM](https://llvm.org/) library to do most of the optimization and final code generation.  This automatically enables a wide range of optimizations that you don't even have to think about.  If we were to inspect the output of the compiler for the previous random directions example, we would find that:\n\n* The function body for `spherical_to_cartesian()` was inlined directly into the body of the for loop in `random_directions`, eliminating the overhead of making a function call.\n* The separate calls to `sin()` and `cos()` were combined into a single, faster call to an internal `sincos()` function.\n\nThese kinds of cross-function optimizations are one of the reasons that Numba can sometimes outperform compiled NumPy code.\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /opt/conda/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n---\n",
    "supporting": [
      "6_0_Numba_tutorial_files"
    ],
    "filters": []
  }
}