{
  "hash": "f1c04599e89bb1f861b776c7e20c9017",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n\n# SIMD Autovectorization in Numba\n\nMost modern CPUs have support for instructions that apply the same operation to multiple data elements simultaneously.  These are called \"Single Instruction, Multiple Data\" (SIMD) operations, and the LLVM backend used by Numba can generate them in some cases to execute loops more quickly.  (This process is called \"autovectorization.\")\n\nFor example, Intel processors have support for SIMD instruction sets like:\n\n* SSE (128-bit inputs)\n* AVX (256-bit inputs)\n* AVX-512 (512-bit inputs, Skylake-X and later or Xeon Phi)\n\nThese wide instructions typically operate on as many values as will fit into an input register.  For AVX instructions, this means that either 8 float32 values or 4 float64 values can be processed as a single input.  As a result, the NumPy dtype that you use can potentially impact performance to a greater degree than when SIMD is not in use.\n\n::: {#22379ed2 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom numba import jit\n```\n:::\n\n\nIt can be somewhat tricky to determine when LLVM has successfully autovectorized a loop.  The Numba team is working on exporting diagnostic information to show where the autovectorizer has generated SIMD code.  For now, we can use a fairly crude approach of searching the assembly language generated by LLVM for SIMD instructions.\n\nIt is also interesting to note what kind of SIMD is used on your system.  On x86_64, the name of the registers used indicates which level of SIMD is in use:\n\n* SSE: `xmmX`\n* AVX/AVX2: `ymmX`\n* AVX-512: `zmmX`\n\nwhere X is an integer.\n\n**Note**: The method we use below to find SIMD instructions will only work on Intel/AMD CPUs.  Other platforms have entirely different assembly language syntax for SIMD instructions.\n\n::: {#dcb50ca0 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=2}\n``` {.python .cell-code}\ndef find_instr(func, keyword, sig=0, limit=5):\n    count = 0\n    for l in func.inspect_asm(func.signatures[sig]).split('\\n'):\n        if keyword in l:\n            count += 1\n            print(l)\n            if count >= limit:\n                break\n    if count == 0:\n        print('No instructions found')\n```\n:::\n\n\n## Basic SIMD\n\nLet's start with a simple function that returns the square difference between two arrays, as you might write for a least-squares optimization:\n\n::: {#4879946c .cell slideshow='{\"slide_type\":\"-\"}' execution_count=3}\n``` {.python .cell-code}\n@jit(nopython=True)\ndef sqdiff(x, y):\n    out = np.empty_like(x)\n    for i in range(x.shape[0]):\n        out[i] = (x[i] - y[i])**2\n    return out\n```\n:::\n\n\n::: {#e1f24ea8 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=4}\n``` {.python .cell-code}\nx32 = np.linspace(1, 2, 10000, dtype=np.float32)\ny32 = np.linspace(2, 3, 10000, dtype=np.float32)\nsqdiff(x32, y32)\n```\n:::\n\n\n::: {#79b7bd07 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=5}\n``` {.python .cell-code}\nx64 = x32.astype(np.float64)\ny64 = y32.astype(np.float64)\nsqdiff(x64, y64)\n```\n:::\n\n\nNumba has created two different implementations of the function, one for `float32` 1-D arrays, and one for `float64` 1-D arrays:\n\n::: {#dee496f7 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=6}\n``` {.python .cell-code}\nsqdiff.signatures\n```\n:::\n\n\nThis allows Numba (and LLVM) to specialize the use of the SIMD instructions for each situation.  In particular, using lower precision floating point allows twice as many values to fit into a SIMD register.  We will see that for the same number of elements, the `float32` calculation goes twice as fast:\n\n::: {#619f7be4 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=7}\n``` {.python .cell-code}\n%timeit sqdiff(x32, y32)\n%timeit sqdiff(x64, y64)\n```\n:::\n\n\nWe can check for SIMD instructions in both cases.  (Due to the order of compilation above, signature 0 is the `float32` implementation and signature 1 is the `float64` implementation.)\n\n::: {#96168009 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=8}\n``` {.python .cell-code}\nprint('float32:')\nfind_instr(sqdiff, keyword='subp', sig=0)\nprint('---\\nfloat64:')\nfind_instr(sqdiff, keyword='subp', sig=1)\n```\n:::\n\n\nIn x86_64 assembly, SSE uses `subps` for \"subtraction packed single precision\" (AVX uses `vsubps`), representing vector float32 operations.  The `subpd` instruction (AVX = `vsubpd`) stands for \"subtraction packed double precision\", representing float64 operations.\n\n## SIMD and Division\n\nIn general, the autovectorizer cannot deal with branches inside loops, although this is an area where LLVM is likely to improve in the future.  Your best bet for SIMD acceleration is to only have pure math operations in the loop.\n\nAs a result, you would naturally assume a function like this would be OK:\n\n::: {#cd549b91 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=9}\n``` {.python .cell-code}\n@jit(nopython=True)\ndef frac_diff1(x, y):\n    out = np.empty_like(x)\n    for i in range(x.shape[0]):\n        out[i] = 2 * (x[i] - y[i]) / (x[i] + y[i])\n    return out\n```\n:::\n\n\n::: {#7b9016a3 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=10}\n``` {.python .cell-code}\nfrac_diff1(x32, y32)\n```\n:::\n\n\n::: {#d4252b2a .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=11}\n``` {.python .cell-code}\nfind_instr(frac_diff1, keyword='subp', sig=0)\n```\n:::\n\n\n`No instructions found`?!\n\nThe problem is that division by zero can behave in two different ways:\n\n* In Python, division by zero raises an exception.\n* In NumPy, division by zero results in a `NaN`, like in C.\n\nBy default, Numba `@jit` follows the Python convention, and `@vectorize`/`@guvectorize` follow the NumPy convention.  When following the Python convention, a simple division operation `r = x / y` expands out into something like:\n\n``` python\n\nif y == 0:\n    raise ZeroDivisionError()\nelse:\n    r = x / y\n```\n\nThis branching code causes the autovectorizer to give up, and no SIMD to be generated for our example above.\n\nFortunately, Numba allows you to override the \"error model\" of the function if you don't want a `ZeroDivisionError` to be raised:\n\n::: {#7bf99df5 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=12}\n``` {.python .cell-code}\n@jit(nopython=True, error_model='numpy')\ndef frac_diff2(x, y):\n    out = np.empty_like(x)\n    for i in range(x.shape[0]):\n        out[i] = 2 * (x[i] - y[i]) / (x[i] + y[i])\n    return out\n```\n:::\n\n\n::: {#c650294a .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=13}\n``` {.python .cell-code}\nfrac_diff2(x32, y32)\n```\n:::\n\n\n::: {#e4cc9445 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=14}\n``` {.python .cell-code}\nfind_instr(frac_diff2, keyword='subp', sig=0)\n```\n:::\n\n\nWe have SIMD instructions again, but when we check the speed:\n\n::: {#833a8577 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=15}\n``` {.python .cell-code}\n%timeit frac_diff2(x32, y32)\n%timeit frac_diff2(x64, y64)\n```\n:::\n\n\nThis is faster than the no-SIMD case, but there doesn't seem to be a speed benefit with `float32` inputs.  What's going on?\n\nThe remaining issue is very subtle.  We can see it if we look at a type-annotated version of the function:\n\n::: {#90b4ec63 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=16}\n``` {.python .cell-code}\nfrac_diff2.inspect_types(pretty=True)\n```\n:::\n\n\nIf you expand out line 5 in the float32 version of the function, you will see the following bit of Numba IR:\n\n```\n$const28.2 = const(float, 2.0) :: float64\n$28.5 = getitem(value=x, index=i) :: float32\n$28.8 = getitem(value=y, index=i) :: float32\n$28.9 = $28.5 - $28.8 :: float32\ndel $28.8\ndel $28.5\n$28.10 = $const28.2 * $28.9 :: float64\n```\n\nNotice that the constant `2` has been typed as a float64 value.  Later, this causes the multiplication `2 * (x[i] - y[i]` to promote up to float64, and then the rest of the calculation becomes float64.  This is a situation where Numba is being overly conservative (and should be fixed at some point), but we can tweak this behavior by casting the constant to the type we want:\n\n::: {#f8b0aa02 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=17}\n``` {.python .cell-code}\n@jit(nopython=True, error_model='numpy')\ndef frac_diff3(x, y):\n    out = np.empty_like(x)\n    dt = x.dtype # Cast the constant using the dtype of the input\n    for i in range(x.shape[0]):\n        # Could also use np.float32(2) to always use same type, regardless of input\n        out[i] = dt.type(2) * (x[i] - y[i]) / (x[i] + y[i])\n    return out\n```\n:::\n\n\n::: {#335a6952 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=18}\n``` {.python .cell-code}\nfrac_diff3(x32, y32)\n```\n:::\n\n\n::: {#06694ecb .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=19}\n``` {.python .cell-code}\n%timeit frac_diff3(x32, y32)\n%timeit frac_diff3(x64, y64)\n```\n:::\n\n\nNow our float32 version is nice and speedy (and 6x faster than what we started with, if we only care about float32).\n\n## SIMD and Reductions\n\nThe autovectorizer can also optimize reduction loops, but only with permission.  Normally, compilers are very careful not to reorder floating point instructions because floating point arithmetic is approximate, so mathematically allowed transformations do not always give the same result.  For example, it is not generally true for floating point numbers that:\n\n```\n(a + (b + c)) == ((a + b) + c)\n```\n\nFor many situations, the round-off error that causes the difference between the left and the right is not important, so changing the order of additions is acceptable for a performance increase.\n\nTo allow reordering of operations, we need to tell Numba to enable `fastmath` optimizations:\n\n::: {#6b4095e8 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=20}\n``` {.python .cell-code}\n@jit(nopython=True)\ndef do_sum(A):\n    acc = 0.\n    # without fastmath, this loop must accumulate in strict order\n    for x in A:\n        acc += x**2\n    return acc\n\n@jit(nopython=True, fastmath=True)\ndef do_sum_fast(A):\n    acc = 0.\n    # with fastmath, the reduction can be vectorized as floating point\n    # reassociation is permitted.\n    for x in A:\n        acc += x**2\n    return acc\n```\n:::\n\n\n::: {#85d3e5a6 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=21}\n``` {.python .cell-code}\ndo_sum(x32)\nfind_instr(do_sum, keyword='mulp')  # look for vector multiplication\n```\n:::\n\n\n::: {#1432d828 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=22}\n``` {.python .cell-code}\ndo_sum_fast(x32)\nfind_instr(do_sum_fast, keyword='mulp')\n```\n:::\n\n\nThe fast version is 4x faster:\n\n::: {#5d7b329f .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=23}\n``` {.python .cell-code}\n%timeit do_sum(x32)\n%timeit do_sum_fast(x32)\n```\n:::\n\n\n## SIMD and Special Functions\n\nIf you follow the above guidelines, SIMD autovectorization will work for all basic math operations (`+`,`-`,`*`,`\\`), but generally will not work for function calls in the loop, unless LLVM can inline the function and there is only basic math in the function body.\n\nHowever, we build Numba (if you get conda packages from Anaconda or wheels from PyPI) using a patched version of LLVM that supports vectorization of special math functions when Intel SVML (\"Short Vector Math Library\") is present.  This library comes with the Intel compiler, and is also freely redistributable.  We've installed it in the current conda environment using `conda install -c numba icc_rt`, as we can verify here:\n\n::: {#3a9717c9 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=24}\n``` {.python .cell-code}\n! conda list icc_rt\n```\n:::\n\n\nThanks to this library, we can still get SIMD vectorization in a function like this:\n\n::: {#6aa2da16 .cell slideshow='{\"slide_type\":\"-\"}' execution_count=25}\n``` {.python .cell-code}\nSQRT_2PI = np.sqrt(2 * np.pi)\n\n@jit(nopython=True, error_model='numpy', fastmath=True)\ndef kde(x, means, widths):\n    '''Compute value of gaussian kernel density estimate.\n    \n    x - location of evaluation\n    means - array of kernel means\n    widths - array of kernel widths\n    '''\n    n = means.shape[0]\n    acc = 0.\n    for i in range(n):\n        acc += np.exp( -0.5 * ((x - means[i]) / widths[i])**2 ) / widths[i]\n    return acc / SQRT_2PI / n\n```\n:::\n\n\n::: {#46e2a11c .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=26}\n``` {.python .cell-code}\n# The distribution we are approximating is flat between -1 and 1, so we expect a KDE value of ~0.5 everywhere\nmeans = np.random.uniform(-1, 1, size=10000)\n# These widths are not selected in any reasonable way.  Consult your local statistician before approximating a PDF.\nwidths = np.random.uniform(0.1, 0.3, size=10000)\n\nkde(0.4, means, widths)\n```\n:::\n\n\nWe can see that SIMD instructions were generated:\n\n::: {#6cd9c871 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=27}\n``` {.python .cell-code}\nfind_instr(kde, 'subp')\n```\n:::\n\n\nWe can also see that calls to the special Intel SVML functions for `exp` were generated:\n\n::: {#9af269da .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=28}\n``` {.python .cell-code}\nfind_instr(kde, keyword='svml')\n```\n:::\n\n\n::: {#e4b4b465 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=29}\n``` {.python .cell-code}\n%timeit kde(0.4, means, widths)\n```\n:::\n\n\nIf we recompile the function (which is possible since the `.py_func` attribute holds the original Python function) with the extra flags to allow division and reductions to work, this stops all autovectorization of the loop:\n\n::: {#5f57b028 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=30}\n``` {.python .cell-code}\nslow_kde = jit(nopython=True)(kde.py_func)\n\nslow_kde(0.4, means, widths)\n```\n:::\n\n\nNote that we get a slightly different answer, both due to the different order of operations, and the small differences in SVML `exp` compared to the default `exp`.  We also see that there is no SIMD or calls to SVML:\n\n::: {#21067714 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=31}\n``` {.python .cell-code}\nfind_instr(slow_kde, keyword='subp')\nprint('---')\nfind_instr(slow_kde, keyword='svml')\n```\n:::\n\n\nAnd the function is much slower than the original:\n\n::: {#e33b19c8 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=32}\n``` {.python .cell-code}\n%timeit kde(0.4, means, widths)\n%timeit slow_kde(0.4, means, widths)\n```\n:::\n\n\nAnd only the SIMD vectorized version is faster than doing this in pure NumPy:\n\n::: {#54fea33a .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=33}\n``` {.python .cell-code}\ndef numpy_kde(x, means, widths):\n    acc = (np.exp( -0.5 * ((x - means) / widths)**2 ) / widths).mean()\n    # .mean() already divides by n\n    return acc / SQRT_2PI\n```\n:::\n\n\n::: {#fd9a1068 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=34}\n``` {.python .cell-code}\nnumpy_kde(0.4, means, widths)\n```\n:::\n\n\n::: {#5e71d12f .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=35}\n``` {.python .cell-code}\n%timeit numpy_kde(0.4, means, widths)\n```\n:::\n\n\nWhy is NumPy as fast as it is?  In this case, it is because the Anaconda build of NumPy uses MKL to accelerate (with SIMD and threads) many of the individial ufuncs, so it is only when Numba can combine all the operations together that the speed boost emerges.\n\nIncidentally, although we wrote out the iteration for `kde` as a for loop to highlight what was going on, you still get the benefit of SIMD in Numba when compiling array expressions.  We could have compiled `numpy_kde` directly:\n\n::: {#0158675b .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=36}\n``` {.python .cell-code}\nnumba_numpy_kde = jit(nopython=True, error_model='numpy', fastmath=True)(numpy_kde)\n\nnumba_numpy_kde(0.4, means, widths)\n```\n:::\n\n\n::: {#4eec2307 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=37}\n``` {.python .cell-code}\nfind_instr(numba_numpy_kde, keyword='subp')\nprint('---')\nfind_instr(numba_numpy_kde, keyword='svml')\n```\n:::\n\n\nAnd it is nearly as fast as our manual looping version, and 2x faster than NumPy alone:\n\n::: {#58d42487 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=38}\n``` {.python .cell-code}\n%timeit kde(0.4, means, widths)\n%timeit numba_numpy_kde(0.4, means, widths)\n%timeit numpy_kde(0.4, means, widths)\n```\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /home/fradav/.micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.6\n---\n",
    "supporting": [
      "6_2_Simd_numba_autovec_tutorial_files"
    ],
    "filters": []
  }
}