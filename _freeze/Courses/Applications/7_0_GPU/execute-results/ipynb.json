{
  "hash": "43cfa0f6aa9cb587b3b58092573ab02f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: GPU computing with Numba (introduction)\n---\n\n\n> \"[Numba](https://numba.pydata.org/) is an open source JIT compiler that translates a subset of Python and NumPy code into fast machine code.\"\n\nNumba offers GPU support (through CUDA). See the official [documentation](https://numba.pydata.org/numba-doc/latest/cuda/index.html) or this [NYU course](https://nyu-cds.github.io/python-numba/05-cuda/)\n\n## Terminology\n\nSeveral important terms in the topic of CUDA programming are listed here:\n\n-   host: the CPU along with the system memory (RAM)\n\n-   device: the GPU\n\n-   host memory: the system main memory\n\n-   device memory: onboard memory on a GPU card\n\n-   kernel: a GPU function launched by the host and executed on the device\n\n-   device function: a GPU function executed on the device which can only be called from the device (i.e. from a kernel or another device function)\n\n## First example: array reduction\n\nIn our examples: - 128 threads (on 64 CPU cores) to run CPU computing - Nvidia A10 GPU to run GPU computing\n\n|                                |                                                                                                                                     |\n|------------------------------------|------------------------------------|\n| FP32                           | 31.2 teraFLOPS                                                                                                                      |\n| TF32 Tensor Core               | 62.5 teraFLOPS                                                                                                                      |\n| BFLOAT16 Tensor Core           | 125 teraFLOPS                                                                                                                       |\n| FP16 Tensor Core               | 125 teraFLOPS                                                                                                                       |\n| INT8 Tensor Core               | 250 TOPS                                                                                                                            |\n| INT4 Tensor Core               | 500 TOPS                                                                                                                            |\n| RT Core                        | 72 RT Cores                                                                                                                         |\n| Encode/decode                  | 1 encoder2 decoder (+AV1 decode)                                                                                                    |\n| GPU memory                     | 24GB GDDR6                                                                                                                          |\n| GPU memory bandwidth           | 600GB/s                                                                                                                             |\n| Interconnect                   | PCIe Gen4 64GB/s                                                                                                                    |\n| Form factors                   | Single-slot, full-height, full-length (FHFL)                                                                                        |\n| Max thermal design power (TDP) | 150W                                                                                                                                |\n| vGPU software support          | NVIDIA Virtual PC, NVIDIA Virtual Applications, NVIDIA RTX Virtual Workstation, NVIDIA Virtual Compute Server, NVIDIA AI Enterprise |\n\n: A10 Technical Specifications and Features\n\n### requirements\n\n::: {#20428c0f .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n# import matplotlib.pyplot as plt\n\nfrom numba import cuda, set_num_threads\nimport plotly.io as pio\npio.renderers.default = \"notebook+plotly_mimetype+svg\"\n\nset_num_threads(128)\nfrom numba.core.errors import NumbaPerformanceWarning\nimport warnings\n\nwarnings.simplefilter('ignore', category=NumbaPerformanceWarning)\n```\n:::\n\n\n### Reduction algorithm\n\n::: {#c1c6f937 .cell execution_count=2}\n``` {.python .cell-code}\n@cuda.reduce\ndef sum_reduce(a, b):\n    return a + b\n```\n:::\n\n\n**Attention**: the first call to `sum_reduce` will trigger a compilation step so with Numba operators, we always need to run a blank run first (on small data to avoid high computation time).\n\n::: {#a9030b19 .cell execution_count=3}\n``` {.python .cell-code}\n# blank run\nA = np.arange(1,10).astype(np.float32)\nsum_reduce(A)\n```\n:::\n\n\n### Toy example\n\n::: {#81d0e0bc .cell execution_count=4}\n``` {.python .cell-code}\n# generate a vector array of dimension 1E7 with random float32 elements\nA = np.random.normal(loc=0, scale=10, size=1000000).astype(np.float32)\n```\n:::\n\n\n::: {#06fc2847 .cell execution_count=5}\n``` {.python .cell-code}\n# numpy sum reduction\nt1 = %timeit -r 5 -n 800 -q -o A.sum()\n```\n:::\n\n\n::: {#b8506451 .cell execution_count=6}\n``` {.python .cell-code}\nsum_reduce(A)\n# cuda sum reduction\nt2 = %timeit -r 5 -n 800 -q -o sum_reduce(A)\n```\n:::\n\n\n#### Which one is faster ?\n\n::: {#475b5a75 .cell execution_count=7}\n``` {.python .cell-code}\n# numpy sum reduction\nt1\n```\n:::\n\n\n::: {#9d63839c .cell execution_count=8}\n``` {.python .cell-code}\n# cuda sum reduction\nt2\n```\n:::\n\n\n#### The GPU is slower????\n\n### Benchmark numpy array sum vs cuda sum reduction\n\n::: {#698d3a58 .cell execution_count=9}\n``` {.python .cell-code}\ndef benchmark1(N):\n    A = np.random.normal(loc=0, scale=10, size=N).astype(np.float32)\n    # numpy sum reduction\n    t1 = %timeit -r 5 -n 10 -q -o A.sum()\n    # cuda sum reduction\n    t2 = %timeit -r 5 -n 10 -q -o sum_reduce(A)\n    # output\n    return t1.average, t2.average\n```\n:::\n\n\n#### Checking increasing vector size\n\n::: {#d6a4242d .cell execution_count=10}\n``` {.python .cell-code}\n# Powers of 2 vector\nvec_size = [2**exp for exp in range(12,28)]\n```\n:::\n\n\n::: {#88734f51 .cell execution_count=11}\n``` {.python .cell-code}\n# check the list size candidates\nimport plotly.express as px\n\npx.scatter(y=vec_size,width=600,labels={'y':\"Data length\",'x':\"Vector index\"},log_y=True)\n```\n:::\n\n\n#### Run the benchmark\n\n::: {#863382d5 .cell execution_count=12}\n``` {.python .cell-code}\n# run the benchmark\nfrom tqdm.notebook import tqdm\n\nres = []\n\nfor N in tqdm(vec_size):\n    \n    time_res = benchmark1(N)\n    \n    res.append({\n        'N': N,\n        'numpy': time_res[0],\n        'cuda': time_res[1]\n    })\n```\n:::\n\n\n#### Results\n\n::: {#b87252de .cell execution_count=13}\n``` {.python .cell-code}\ndf_res = pd.DataFrame(res)\npx.line(df_res, x='N', y=['numpy', 'cuda'], log_y=True, log_x=True, width=600)\n```\n:::\n\n\n**It is confirmed!!! Why bother using GPU???**\n\n#### Any idea ?\n\n### Bottleneck\n\n-   Host to device (GPU) memory copy\n\n### Solution\n\n-   Copy data to device (GPU) before running the computations\n\nSee Numba dedicated [page](https://numba.pydata.org/numba-doc/latest/cuda/memory.html) for memory management.\n\n::: {#fd43bb62 .cell execution_count=14}\n``` {.python .cell-code}\ndef benchmark2(N):\n    print(f\"sum of {N} elements\")\n    A = np.random.normal(loc=0, scale=10, size=N).astype(np.float32)\n    # numpy sum reduction\n    t1 = %timeit -r 5 -n 10 -q -o A.sum()\n    # copy data to device\n    A_gpu = cuda.to_device(A)\n    # cuda sum reduction\n    t2 = %timeit -r 5 -n 10 -q -o sum_reduce(A_gpu)\n    # output\n    return t1.average, t2.average\n```\n:::\n\n\n::: {#b839a875 .cell execution_count=15}\n``` {.python .cell-code}\n# run the benchmark\nres = []\n\nfor N in tqdm(vec_size):\n    \n    time_res = benchmark2(N)\n    \n    res.append({\n        'N': N,\n        'numpy': time_res[0],\n        'cuda': time_res[1]\n    })\n```\n:::\n\n\n::: {#c0b34356 .cell execution_count=16}\n``` {.python .cell-code}\n# results\ndf_res2 = pd.DataFrame(res)\npx.line(df_res2, x='N', y=['numpy', 'cuda'], log_y=True, log_x=True, width=600)\n```\n:::\n\n\n**GPU is better to do high throughput computing with larger matrices.**\n\n### GPU memory overflow\n\n::: {#042d924f .cell Note='GPU memory overflow on small gpu' execution_count=17}\n``` {.python .cell-code}\ntry:\n    A = np.random.normal(loc=0, scale=10, size=int(2E9)).astype(np.float32)\n    sum_reduce(A)\nexcept Exception as e:\n    print(e)\n```\n:::\n\n\n**To avoid memory overflow:** - [KeOps](https://www.kernel-operations.io/keops/index.html): Kernel Operations (including matrix operations and reduction) on the GPU, with autodiff, without memory overflows\n\n::: {#8e70b09c .cell execution_count=18}\n``` {.python .cell-code}\n# Note: CPU memory overflow\ntry:\n    A = np.random.normal(loc=0, scale=10, size=int(1E12)).astype(np.float32)\n    sum_reduce(A)\nexcept Exception as e:\n    print(e)\n```\n:::\n\n\n### Complex operation on GPU ?\n\n$$\\sum_i \\vert x_i \\vert = \\sum_i (-1)^{I_{\\{x_i < 0\\}}} x_i = \\sum_{i,x_i \\geq 0} x_i - \\sum_{i,x_i < 0} x_i$$\n\nExample: if $x = [-1, 3, 5, -2]$ then we want to compute $1 + 3 + 5 + 2$\n\n::: {#2d4f4b02 .cell execution_count=19}\n``` {.python .cell-code}\n# Numpy reduce\ndef numpy_reduce(vec):\n    return (vec * np.where(vec < 0, -1, 1)).sum()\n\n# numba cpu reduce\nfrom numba import njit, prange, set_num_threads\n\nset_num_threads(8)\n\n@njit(parallel=True)\ndef numba_reduce(A):\n    s = 0\n    # Without \"parallel=True\" in the jit-decorator\n    # the prange statement is equivalent to range\n    for i in prange(A.shape[0]):\n        if A[i] < 0:\n            s += -A[i]\n        else:\n            s += A[i]\n    return s\n\n# cuda reduce\n@cuda.reduce\ndef cuda_reduce(a, b):\n    if b < 0:\n        return a - b\n    else:\n        return a + b\n    \nA = np.random.normal(loc=0, scale=10, size=1000).astype(np.float32)\nnumba_reduce(A)\ncuda_reduce(A)\n```\n:::\n\n\n::: {#658f0e92 .cell execution_count=20}\n``` {.python .cell-code}\n# benchmark\ndef benchmark3(N):\n    print(f\"complex operations on {N} elements\")\n    A = np.random.normal(loc=0, scale=10, size=N).astype(np.float32)\n    # numpy reduction\n    t1 = %timeit -r 2 -n 5 -q -o numpy_reduce(A)\n    # numba reduction\n    t2 = %timeit -r 2 -n 5 -q -o numba_reduce(A)\n    # cuda reduction\n    A_gpu = cuda.to_device(A)\n    t3 = %timeit -r 2 -n 5 -q -o cuda_reduce(A_gpu)\n    # output\n    return t1.average, t2.average, t3.average\n```\n:::\n\n\n::: {#c32cdc8e .cell execution_count=21}\n``` {.python .cell-code}\n# run the benchmark\nres = []\nresspeedup = []\nfor N in tqdm(vec_size):\n    \n    time_res = benchmark3(N)\n    \n    res.append({\n        'N': N,\n        'numpy': time_res[0],\n        'numba_128c': time_res[1],\n        'cuda': time_res[2],\n    })\n    resspeedup.append({\n        'N': N,\n        'numpy/numba': time_res[0]/time_res[1],\n        'numpy/cuda': time_res[0]/time_res[2]\n    })\n```\n:::\n\n\n::: {#ad8e3a72 .cell execution_count=22}\n``` {.python .cell-code}\n# results\ndf_res = pd.DataFrame(res)\nfig = px.line(df_res, x='N', y=['numpy', 'numba_128c', 'cuda'], log_y=True, log_x=True, width=600)\nfig.show()\ndf_resspeedup = pd.DataFrame(resspeedup)\nfig = px.line(df_resspeedup, x='N', y=['numpy/numba', 'numpy/cuda'], log_y=True, log_x=True, width=600)\nfig.show()\n```\n:::\n\n\n## Numba for GPU: next level\n\n### GPU management\n\n::: {#9492909a .cell execution_count=23}\n``` {.python .cell-code}\n# to check available GPU\nfrom numba import cuda\nfor gpu in cuda.list_devices():\n    print(gpu.name)\n    \ncuda.get_current_device().name\n```\n:::\n\n\n### Kernel declaration\n\nkernel function = GPU function meant to be called from CPU code\n\nCharacteristics: - kernels **cannot explicitly return a value** (all result data must be written to an array passed to the function) - kernels **explicitly declare their thread hierarchy when called**: i.e. the number of thread blocks and the number of threads per block\n\n**Attention**: Kernel function are compiled on their first call, we always need to run a blank run first (on small data to avoid high computation time).\n\n::: {#1bfce648 .cell execution_count=24}\n``` {.python .cell-code}\nfrom numba import cuda\n\n@cuda.jit\ndef my_kernel(io_array):\n    \"\"\"\n    Code for kernel.\n    \"\"\"\n    # code here\n```\n:::\n\n\n::: {#b5b3fe63 .cell execution_count=25}\n``` {.python .cell-code}\nimport numpy\n\n# Create the data array - usually initialized some other way\ndata = numpy.ones(256)\n\n# Set the number of threads in a block\nthreadsperblock = 32 \n\n# Calculate the number of thread blocks in the grid\nblockspergrid = (data.size + (threadsperblock - 1)) // threadsperblock\n\n# Now start the kernel\nmy_kernel[blockspergrid, threadsperblock](data)\n\n# Print the result\nprint(data)\n```\n:::\n\n\n**Important**: you have to choose the number of blocks per grid (and hence the block size) and the number of threads per block. The product of the two will give the total number of threads launched.\n\n### Choosing the block size\n\n[Credit](https://nyu-cds.github.io/python-numba/05-cuda/)\n\nThe two-level thread hierarchy is important for the following reasons:\n\n-   On the software side, the block size determines how many threads share a given area of shared memory.\n-   On the hardware side, the block size must be large enough for full occupation of execution units; recommendations can be found in the CUDA C Programming Guide.\n\nThe block size you choose depends on a range of factors, including:\n\n-   The size of the data array\n-   The size of the shared mempory per block (e.g. 64KB)\n-   The maximum number of threads per block supported by the hardware (e.g. 512 or 1024)\n-   The maximum number of threads per multiprocessor (MP) (e.g. 2048)\n-   The maximum number of blocks per MP (e.g. 32)\n-   The number of threads that can be executed concurrently (a \"warp\" i.e. 32)\n\nThe execution of threads in a warp has a big effect on the computational throughput. If all threads in a warp are executing the same instruction then they can all be executed in parallel. But if one or more threads is executing a different instruction, the warp has to be split into groups of threads, and these groups execute serially.\n\n**Rules of thumb for threads per block:**\n\n-   Should be a round multiple of the warp size (32)\n-   A good place to start is 128-512 but benchmarking is required to determine the optimal value.\n\nEach streaming multiprocessor (SP) on the GPU must have enough active warps to achieve maximum throughput. In other words, the blocksize is usually selected to maximize the \"occupancy\". See the [CUDA Occupancy Calculator spreadsheet](http://developer.download.nvidia.com/compute/cuda/CUDA_Occupancy_calculator.xls)for more details.\n\n### Thread positioning\n\n[Credit](https://nyu-cds.github.io/python-numba/05-cuda/)\n\nWhen running a kernel, the kernel function's code is executed by every thread once. It therefore has to know which thread it is in, in order to know which array element(s) it is responsible for. More complex algorithms may define more complex responsibilities, but the underlying principle is the same.\n\nTo help deal with multi-dimensional arrays, CUDA allows you to specify multi-dimensional blocks and grids. In the example above, you could make blockspergrid and threadsperblock tuples of one, two or three integers. Compared to 1-dimensional declarations of equivalent sizes, this doesn't change anything to the efficiency or behaviour of generated code, but can help you write your algorithms in a more natural way.\n\n### Matrix product\n\nNumpy version for comparison\n\n::: {#33efa081 .cell execution_count=26}\n``` {.python .cell-code}\n# numpy version\ndef numpy_matmul(A, B):\n    C = np.matmul(A, B)\n    return C\n```\n:::\n\n\n#### Naive cuda version\n\n::: {#b18f18c4 .cell execution_count=27}\n``` {.python .cell-code}\n@cuda.jit\ndef cuda_matmul(A, B, C):\n    \"\"\"Perform matrix multiplication of C = A * B\n    \"\"\"\n    row, col = cuda.grid(2)\n    if row < C.shape[0] and col < C.shape[1]:\n        tmp = 0.\n        for k in range(A.shape[1]):\n            tmp += A[row, k] * B[k, col]\n        C[row, col] = tmp\n```\n:::\n\n\n![](../figs/matmul.png) [Credit](https://nyu-cds.github.io/python-numba/05-cuda/)\n\n#### Run\n\n::: {#3c782f07 .cell execution_count=28}\n``` {.python .cell-code}\n# data 1000x1000 matrix\nA = np.random.normal(loc=0, scale=10, size=1000**2).astype(np.float32).reshape((1000,1000))\nB = np.random.normal(loc=0, scale=10, size=1000**2).astype(np.float32).reshape((1000,1000))\n```\n:::\n\n\n::: {#455ac73d .cell execution_count=29}\n``` {.python .cell-code}\n# numpy run\n%timeit -r 5 -n 20 -q -o numpy_matmul(A, B)\n```\n:::\n\n\n::: {#74961067 .cell execution_count=30}\n``` {.python .cell-code}\n# Copy the arrays to the device\nA_gpu = cuda.to_device(A)\nB_gpu = cuda.to_device(B)\n\n# Allocate memory on the device for the result\nC_gpu = cuda.device_array((24, 22))\n```\n:::\n\n\n::: {#72128cab .cell execution_count=31}\n``` {.python .cell-code}\n# Configure the blocks\nimport math\nthreadsperblock = (16, 16)\nblockspergrid_x = int(math.ceil(A.shape[0] / threadsperblock[0]))\nblockspergrid_y = int(math.ceil(B.shape[1] / threadsperblock[1]))\nblockspergrid = (blockspergrid_x, blockspergrid_y)\n```\n:::\n\n\n::: {#9e692275 .cell execution_count=32}\n``` {.python .cell-code}\n#\n# CUDA matrix multiplication\n#\n@cuda.jit\ndef cuda_matmul1(A, B, C):\n    \"\"\"Perform square matrix multiplication of C = A * B\n    \"\"\"\n    i, j = cuda.grid(2)\n    if i < C.shape[0] and j < C.shape[1]:\n        tmp = 0.\n        for k in range(A.shape[1]):\n            tmp += A[i, k] * B[k, j]\n        C[i, j] = tmp\n```\n:::\n\n\n::: {#a8ff77ef .cell execution_count=33}\n``` {.python .cell-code}\n# cuda run\n%timeit -r 5 -n 20 -q -o cuda_matmul1[blockspergrid, threadsperblock](A_gpu, B_gpu, C_gpu)\n```\n:::\n\n\n::: {#c8f94739 .cell execution_count=34}\n``` {.python .cell-code}\n# get the result from the GPU\nC = C_gpu.copy_to_host()\n```\n:::\n\n\n::: {#863294c0 .cell execution_count=35}\n``` {.python .cell-code}\nfrom numba import cuda, float32\n\n# Controls threads per block and shared memory usage.\n# The computation will be done on blocks of TPBxTPB elements.\nTPB = 16\n\n@cuda.jit\ndef cuda_fast_matmul(A, B, C):\n    # Define an array in the shared memory\n    # The size and type of the arrays must be known at compile time\n    sA = cuda.shared.array(shape=(TPB, TPB), dtype=float32)\n    sB = cuda.shared.array(shape=(TPB, TPB), dtype=float32)\n\n    x, y = cuda.grid(2)\n\n    tx = cuda.threadIdx.x\n    ty = cuda.threadIdx.y\n    bpg = cuda.gridDim.x    # blocks per grid\n\n    if x >= C.shape[0] and y >= C.shape[1]:\n        # Quit if (x, y) is outside of valid C boundary\n        return\n\n    # Each thread computes one element in the result matrix.\n    # The dot product is chunked into dot products of TPB-long vectors.\n    tmp = 0.\n    for i in range(bpg):\n        # Preload data into shared memory\n        sA[tx, ty] = A[x, ty + i * TPB]\n        sB[tx, ty] = B[tx + i * TPB, y]\n\n        # Wait until all threads finish preloading\n        cuda.syncthreads()\n\n        # Computes partial product on the shared memory\n        for j in range(TPB):\n            tmp += sA[tx, j] * sB[j, ty]\n\n        # Wait until all threads finish computing\n        cuda.syncthreads()\n\n    C[x, y] = tmp\n```\n:::\n\n\n::: {#19f80194 .cell execution_count=36}\n``` {.python .cell-code}\n# Configure the blocks\nthreadsperblock = (TPB, TPB)\nblockspergrid_x = int(math.ceil(A.shape[0] / threadsperblock[1]))\nblockspergrid_y = int(math.ceil(B.shape[1] / threadsperblock[0]))\nblockspergrid = (blockspergrid_x, blockspergrid_y)\n\n# Start the kernel \n%timeit -r 5 -n 20 -q -o cuda_fast_matmul[blockspergrid, threadsperblock](A_gpu, B_gpu, C_gpu)\n```\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /home/fradav/.micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.6\n---\n",
    "supporting": [
      "7_0_GPU_files"
    ],
    "filters": []
  }
}