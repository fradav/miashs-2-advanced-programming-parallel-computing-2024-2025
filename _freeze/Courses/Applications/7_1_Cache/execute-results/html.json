{
  "hash": "6eba5423662c37318f14ffe8ba4a9aae",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: CPU Cache and its impact on computations\n---\n\n\n\n\n## Toy example: list sum\n\n### Setup environment\n\n::: {#d75b0e2d .cell execution_count=1}\n``` {.python .cell-code}\n# requirements\nimport random\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook+plotly_mimetype+svg\"\n```\n:::\n\n\n### Construct a list of integers\n\n::: {#1bcc75e8 .cell execution_count=2}\n``` {.python .cell-code}\n# a list of integers from 1 to 10000 with random order\nitems = list(range(10000))\nrandom.shuffle(items)\n```\n:::\n\n\n### Sum of the list elements\n\n::: {#08557c62 .cell execution_count=3}\n``` {.python .cell-code}\n# vanilla Python\nt1 = %timeit -r 5 -n 50 -q -o sum(items)\n```\n:::\n\n\n::: {#0c15c1dc .cell execution_count=4}\n``` {.python .cell-code}\n# Numpy version\narray = np.array(items)\nt2 = %timeit -r 5 -n 50 -q -o array.sum()\n```\n:::\n\n\n### Which one is faster ?\n\n::: {#e87c4cdb .cell execution_count=5}\n``` {.python .cell-code}\n# vanilla Python time\nt1\n```\n:::\n\n\n::: {#e5ba73ef .cell execution_count=6}\n``` {.python .cell-code}\n# Numpy version time\nt2\n```\n:::\n\n\n## WHY ?\n\n- **List** elements **not contiguous** in memory: loading elements from memory to CPU cache individually\n- **Numpy array** elements **contiguous** in memory: loading elements from memory to CPU cache by batch\n\n![](../figs/array_vs_list.png)\nCredit: [Jake VanderPlas](https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html)\n\n## Benchmark list sum vs numpy array sum\n\n::: {#84836e3f .cell execution_count=7}\n``` {.python .cell-code}\ndef benchmark1(N):\n    print(f\"sum of {N} elements\")\n    items = list(range(N))\n    random.shuffle(items)\n    # vanilla Python\n    t1 = %timeit -r 5 -n 20 -q -o sum(items)\n    # Numpy version\n    array = np.array(items)\n    t2 = %timeit -r 5 -n 20 -q -o array.sum()\n    # output\n    return t1.average, t2.average\n```\n:::\n\n\n### Checking increasing list size\n\n::: {#d4ee1128 .cell execution_count=8}\n``` {.python .cell-code}\nlist_size = np.trunc(10**np.arange(2, 7, 0.2)).astype(int)\n```\n:::\n\n\n::: {#3938c2de .cell execution_count=9}\n``` {.python .cell-code}\n# check the list size candidates\nfig = px.scatter(y=list_size, log_y=True, width=600)\nfig.show()\n```\n:::\n\n\n### Run the benchmark\n\n::: {#d0081866 .cell execution_count=10}\n``` {.python .cell-code}\n# run the benchmark\nres = []\n\nfor N in list_size:\n    \n    time_res = benchmark1(N)\n    \n    res.append({\n        'N': N,\n        'vanilla': time_res[0],\n        'numpy': time_res[1]\n    })\n```\n:::\n\n\n### Results\n\n::: {#e74da7f5 .cell execution_count=11}\n``` {.python .cell-code}\ndf_res = pd.DataFrame(res)\npx.line(df_res, x='N', y=['vanilla', 'numpy'], log_y=True, log_x=True, width=600)\n```\n:::\n\n\n## Benchmark cache effect on numpy array sum\n\n::: {#70807d66 .cell execution_count=12}\n``` {.python .cell-code}\ndef benchmark2(N):\n    print(f\"sum of {N} elements\")\n    items = list(range(N))\n    random.shuffle(items)\n    # Numpy version\n    array = np.array(items)\n    t1 = %timeit -r 5 -n 10 -q -o array.sum()\n    # output\n    return t1.average\n```\n:::\n\n\n### Checking increasing list size\n\n### Run the benchmark\n\n::: {#119c1003 .cell execution_count=13}\n``` {.python .cell-code}\n# run the benchmark\nres = []\n\nfor N in list_size:\n    \n    time_res = benchmark2(N)\n    \n    res.append({\n        'N': N,\n        'numpy': time_res\n    })\n```\n:::\n\n\n### Results\n\n::: {#ce90149f .cell execution_count=14}\n``` {.python .cell-code}\ndf_res2 = pd.DataFrame(res)\npx.line(df_res2, x='N', y='numpy', log_y=True, log_x=True, width=600)\n```\n:::\n\n\n",
    "supporting": [
      "7_1_Cache_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}