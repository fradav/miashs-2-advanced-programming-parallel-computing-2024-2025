{
  "hash": "22969282a12830a6bef8447f54baae03",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Numpy Workout\nsubtitle: A short remainder on `numpy` with exercises\n---\n\n\n# Starting slowly\n\nShort application about `numpy`, just a refresh\n\n## Some loops\n\n::: {#dd2a1a21 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\na = np.random.rand(100)\nb = np.random.rand(100)\n```\n:::\n\n\n## Dot product\n\nExercises: \n\n1. numpy dot product of a and b\n2. write manual loop\n3. compare results\n\n::: {#2384d802 .cell tags='[\"solution\"]' execution_count=2}\n``` {.python .cell-code}\nnp.dot(a,b)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nnp.float64(22.887846234193105)\n```\n:::\n:::\n\n\n::: {#12da945c .cell tags='[\"solution\"]' execution_count=3}\n``` {.python .cell-code}\nresdot=0\nfor i in range(100):\n    resdot += a[i]*b[i]\nresdot\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nnp.float64(22.887846234193102)\n```\n:::\n:::\n\n\n## Matrix product\n\nExercice:\n\n1. Generate 2 random matrix $5 \\times 5$\n2. Numpy matrix product of both\n3. Manual loop, compare result\n4. Manual loop with numpy dot product of row-column, conpare resurt\n\nUse `np.testing` with the right assert function for comparison purpose.\n\n::: {#abd0c392 .cell tags='[\"solution\"]' execution_count=4}\n``` {.python .cell-code}\nA = np.random.rand(5,5)\nB = np.random.rand(5,5)\n```\n:::\n\n\n::: {#1b365b4e .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\nC = A @ B\n```\n:::\n\n\n::: {#404b4c72 .cell tags='[\"solution\"]' execution_count=6}\n``` {.python .cell-code}\nCres = np.zeros((5,5))\nfor i in range(5):\n    for j in range(5):\n        for k in range(5):\n            Cres[i,j] += A[i,k] * B[k,j]\nnp.testing.assert_array_almost_equal(Cres,C)\n```\n:::\n\n\n::: {#0248e6d6 .cell tags='[\"solution\"]' execution_count=7}\n``` {.python .cell-code}\nCres = np.zeros((5,5))\nfor i in range(5):\n    for j in range(5):\n        Cres[i,j] = np.dot(A[i],B[:,j])\nnp.testing.assert_array_almost_equal(Cres,C)\n```\n:::\n\n\n## Colum-wise sum\n\n::: {#75b27770 .cell execution_count=8}\n``` {.python .cell-code}\nD = np.arange(10).reshape(2,5)\nD\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n```\n:::\n:::\n\n\nExercise:\n\n1. Col-wise sum of D with numpy\n2. the same with loop(s), compare results\n\n::: {#3e328a55 .cell tags='[\"solution\"]' execution_count=9}\n``` {.python .cell-code}\nDrowsum = np.sum(D,axis=0)\nDrowsum\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([ 5,  7,  9, 11, 13])\n```\n:::\n:::\n\n\n::: {#8496dfb8 .cell tags='[\"solution\"]' execution_count=10}\n``` {.python .cell-code}\nDrowsumres = np.zeros(5)\nfor j in range(5):\n    for i in range(2):\n        Drowsumres[j] += D[i,j]\nnp.testing.assert_array_equal(Drowsum,Drowsumres)\n```\n:::\n\n\n# Ramping up, sequence searching\n\nA frequent in image processing is to find a precise pattern in a given image. We will restrict ourselves to the one-dimensional case (a list of positive integers), and we will first try to implement this algorithm.\n\nWe want a function that takes as argument two unidimensional numpy arrays, the first contains the data, and the second the sequence we want to find in the data. The function returns the list of indices in the array of data, indices which correspond to the start of each subsequence of data identical to the sequence we are searching for.\n\n## Illustration \n\n:::{.content-hidden when-format=\"revealjs\"}\n![Sequence search](../tikz-figures/sequence-search.svg){width=100%}\n:::\n\n:::{.content-visible when-format=\"revealjs\"}\n\n[]{.fragment .fade-in-then-out}\n\n```yaml { .animate style=\"width: 100%;\" src=\"../tikz-figures/sequence-search.svg\"}\nsetup:\n  - element: \"[id^=pair], #firstocc, #secocc\"\n    modifier: \"opacity\"\n    parameters: [ 0 ]\nanimation:\n  - []\n  - \n    - element: \"#pair1\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair1\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair2\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair2\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair3\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair3\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair4, #firstocc\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair5\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair5\"\n      modifier: \"opacity\"\n      parameters: [ 0 ] \n    - element: \"#pair6\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair6\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair7\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair7\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair8, #secocc\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair9\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair9\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n    - element: \"#pair10\"\n      modifier: \"opacity\"\n      parameters: [ 1 ]\n    - element: \"#pair10\"\n      modifier: \"opacity\"\n      parameters: [ 0 ]\n```\n:::\n\n## First blocks\n\n::: {#1f399094 .cell execution_count=11}\n``` {.python .cell-code}\ndata = np.array([1,3,2,0,1,9,2,0,1,1,0],dtype=np.uint8)\nsequence = np.array([0,1],dtype=np.uint8)\n```\n:::\n\n\nWe want to get\n\n```python\nnumpy_search_sequence(data,séquence)\n```\n\n```python\narray([3, 7], dtype=int64)\n```\n\n## Exercise\n\nFirst create an increasing list of indices avec `np.arange` with the same size of the search sequence\n\n```python\nseq_size = \nseq_ind = \n```\n\n::: {#c1c48191 .cell tags='[\"solution\"]' execution_count=12}\n``` {.python .cell-code}\nseq_size = sequence.size\nseq_ind = np.arange(seq_size)\nseq_ind\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([0, 1])\n```\n:::\n:::\n\n\n## Exercise cont.\n\nCall `data_size` the size of the input data.\n\nWe now want a list of increasing indices from 0 to `data_size-seq_size`, but transformed into a column vector thanks to `reshape` of numpy. Call `data_ind` this column vector (dimesion `(data_size-seq_size+1,1)`).\n\n```python\ndata_size =\ncor_size = data_size-seq_size+1\ndata_ind = \n```\n\n::: {#1ff0769c .cell tags='[\"solution\"]' execution_count=13}\n``` {.python .cell-code}\ndata_size = data.size\ncor_size = data_size-seq_size+1\ndata_ind = np.arange(cor_size).reshape((cor_size,1))\ndata_ind\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([[0],\n       [1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6],\n       [7],\n       [8],\n       [9]])\n```\n:::\n:::\n\n\n## Broadcasting\n\nWe will then use numpy's *broadcasting* rules to create a vector of dimension `(data_size-seq_size+1,2)` which contains the list of all possible adjacent sequences of indices that we want to locate in the data as follows:\n\n```python\narray([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10]])\n```\n\n## Broadcasting cont.\n\nWhat very simple operation to perform on `data_ind` and `seq_ind` to get this?\n\n— [official numpy doc](https://numpy.org/doc/stable/user/basics.broadcasting.html)\n\n— [french explanation](https://nbhosting.inria.fr/builds/ue12-python-numerique/handouts/latest/2-05-numpy-broadcast.html)\n\n\n## Broadcasting cont. 2\n\n::: {#fcb1bf90 .cell tags='[\"solution\"]' execution_count=14}\n``` {.python .cell-code}\ndata_ind + seq_ind\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10]])\n```\n:::\n:::\n\n\n(10,1) and (2,) are compatible because the first array `data_ind` contains an unit dimension on the right, the *broadcasting*, it will first “stretch” on this dimension to match that of ` seq_ind`, then *broadcast* the addition of `seq_ind` over the ten lines, the first element of `ind_seq` being added to the first element of a line, then the second element of `seq_ind` adding to the second element of the corresponding row. The operation is thus repeated on each line.\n\n## Indice expression\n\nUsing the result of the previous question as indices for the array of `data`, apply the search for sequences that are correctly *matched* with a simple operator. Explain why the result has the same dimension (*shape*) as `data_ind` and not as `data`.\n\n```python\narray([[False, False],\n       [False, False],\n       [False, False],\n       [ True,  True],\n       [False, False],\n       [False, False],\n       [False, False],\n       [ True,  True],\n       [False,  True],\n       [False, False]])\n```\n\n::: {#2c12ebfc .cell tags='[\"solution\"]' execution_count=15}\n``` {.python .cell-code}\ndata[data_ind + seq_ind] == sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([[False, False],\n       [False, False],\n       [False, False],\n       [ True,  True],\n       [False, False],\n       [False, False],\n       [False, False],\n       [ True,  True],\n       [False,  True],\n       [False, False]])\n```\n:::\n:::\n\n\n## Indice expression cont.\n\nIt is the array `data_ind + seq_ind` which is used to *index* the array of `data`, the corresponding indices are simply used on `data` to provide the result. Next, numpy performs a *broadcasting* with the `==` operator which returns a boolean for each element *broadcasted* from both sides (as before, first element of each line of the first operand on first element of the sequence to match, etc.)\n\n## Final match\n\nNow we are looking for all lines having a perfect match, ie only `True`. Use the `np.all` function for this\n\n```python\narray([False, False, False,  True, False, False, False,  True, False,\n       False])\n```\n\n::: {#8cc45a61 .cell tags='[\"solution\"]' execution_count=16}\n``` {.python .cell-code}\nnp.all(data[data_ind + seq_ind] == sequence,1)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([False, False, False,  True, False, False, False,  True, False,\n       False])\n```\n:::\n:::\n\n\n## Indice extraction\n\nFinally we now extract the indices where there is \"match\" thanks to `np.nonzero`\n\n```python\narray([3, 7], dtype=int64)\n```\n\n::: {#b60b2d9f .cell tags='[\"solution\"]' execution_count=17}\n``` {.python .cell-code}\nnp.nonzero(np.all(data[data_ind + seq_ind] == sequence,1))[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([3, 7])\n```\n:::\n:::\n\n\n## External resources\n\n- Exercises from [numpy-100](https://github.com/rougier/numpy-100)\n- Data Sciences oriented exercises there [101 NumPy Exercises for Data Analysis (Python)](https://www.machinelearningplus.com/python/101-numpy-exercises-python/)\n- [W3Schools numpy exercises](https://www.w3schools.com/python/numpy/numpy_exercises.asp)\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /nfs/home/collinf/micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n---\n",
    "supporting": [
      "0_Numpy_Workout-sol_files"
    ],
    "filters": []
  }
}