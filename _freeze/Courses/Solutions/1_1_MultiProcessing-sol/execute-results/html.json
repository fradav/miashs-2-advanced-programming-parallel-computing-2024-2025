{
  "hash": "24032b6496d35d74bd2e53a81cdfe687",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: MultiProcessing, Strong Scaling\n---\n\n\n\n\n## ⚠️⚠️⚠️⚠️ Attention ⚠️⚠️⚠️⚠️\n Under _Windows_, with python the multiprocessing module `multiprocessing` works in a normal script but **not in notebooks**.\n \nIf you absolutely must use Windows, use[WSL](https://docs.microsoft.com/fr-fr/windows/wsl/)\n\n# Strong Scaling\n\n## Prerequisites\n\nFor this TP, set the number of **physical** cores available (8 on the cluster nodes), not the number of logical cores.\n\n::: {#a043281f .cell execution_count=2}\n``` {.python .cell-code}\nncores = 8 # 8 on the cluster nodes\n```\n:::\n\n\n::: {#d54b1ae7 .cell execution_count=3}\n``` {.python .cell-code}\nimport math\n```\n:::\n\n\n# Introduction\n\n## Basic functions\n\nMake a function `is_prime` that tests whether an integer $n$ strictly greater than 2 is prime or not.\n\nHint: First check that it is not even, then list all odd numbers from 3 to $\\sqrt{n}$ (upper rounding) and test whether they are factors.\n\n::: {#887fec1d .cell tags='[\"solution\"]' execution_count=4}\n``` {.python .cell-code}\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n```\n:::\n\n\nMake a function `total_primes` that counts the number of primes in a list.\n\n::: {#eac25e0e .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\ndef total_primes(l):\n    n = 0\n    for i in l:\n        if (i > 0) & (i <= 2):\n            n=n+1\n        elif is_prime(i):\n            n=n+1                \n    return n\n```\n:::\n\n\nCalculate the number of primes from 1 to $N=100 000$ with this function\n\n::: {#3b0cbccf .cell execution_count=6}\n``` {.python .cell-code}\nN=100000\n```\n:::\n\n\n::: {#cf99763f .cell execution_count=7}\n``` {.python .cell-code}\ntotal_primes(range(1,N+1))\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n9593\n```\n:::\n:::\n\n\n## Time measurement\n\nUse `%timeit` to measure the average time taken to count the number of primes up to $N=100000$.\n(note: by default, `timeit` repeats the calculation $7times{}10$ to obtain a reliable average. Please refer to the [magic](https://ipython.readthedocs.io/en/stable/interactive/magics.html) and [timeit](https://docs.python.org/3.9/library/timeit.html) docs).\n\nStore measurements using the -o option in timeit\n\n::: {#2398b5d9 .cell execution_count=8}\n``` {.python .cell-code}\norig_time = %timeit -o total_primes(range(1,N+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n71.4 ms ± 238 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n:::\n:::\n\n\n# First steps\n\nOur first attempt at multiprocessing will involve partitioning the count into 2. We'll run two processes in parallel on $\\{1,...,N/2\\}$ and $\\{N/2+1,...,N\\}$.\n\nComplete the following code ([source](https://notebook.community/izapolsk/integration_tests/notebooks/MultiProcessing)).\n\nCheck the result and the performance gain with `%timeit`.\n\n::: {#47464b29 .cell execution_count=9}\n``` {.python .cell-code}\nfrom multiprocessing.pool import Pool\n\ndef split_total(N):\n    with Pool(2) as pool:\n        return sum(pool.map(total_primes, ...))\n```\n:::\n\n\n::: {#e61befdb .cell tags='[\"solution\"]' execution_count=10}\n``` {.python .cell-code}\nfrom multiprocessing.pool import Pool\n\ndef split_total(N):\n    with Pool(2) as pool:\n        return sum(pool.map(total_primes, [range(1,int(N/2)), range(int(N/2)+1,N+1)]))\n```\n:::\n\n\n::: {#70646b02 .cell execution_count=11}\n``` {.python .cell-code}\nsplit_total(N)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n9593\n```\n:::\n:::\n\n\n::: {#24366cca .cell execution_count=12}\n``` {.python .cell-code}\nsplit_time = %timeit -o split_total(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n52 ms ± 103 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n:::\n:::\n\n\n::: {#73989247 .cell execution_count=13}\n``` {.python .cell-code}\nprint(\"Gain with split : {:.1f}\".format(orig_time.average/split_time.average))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGain with split : 1.4\n```\n:::\n:::\n\n\n# Generalization\n\nGeneralize the function with partitioning into *n* tasks instead of just 2. We'll use a generalized `multi_process_list` function, which takes as arguments :\n- f` the main computation function, which takes an integer list as argument\n- n` the number of partitions (here, one partition = task)\n- par_f` a function which takes as argument a list and a number of partitions to be performed, and returns the list of partitions in this list\n- l` the list to be partitioned\n\n::: {#782d73cb .cell execution_count=14}\n``` {.python .cell-code}\ndef multi_process_list(f,n,par_f,l):\n    with Pool(ncores) as pool:\n        return sum(pool.map(...)\n```\n:::\n\n\nFirst, we write the `naive_par` partitioning function.\n\n::: {#7557fa7e .cell execution_count=15}\n``` {.python .cell-code}\ndef naive_par(lst,n):\n    return ...\n```\n:::\n\n\nWe'll use the `chunks` function, which partitions a list into chunks of fixed size (except for the last one).\n\nWe'll test the gain obtained with 8 tasks/partitions.\n\n::: {#c1e90d67 .cell execution_count=16}\n``` {.python .cell-code}\ndef chunks(lst, m):\n    \"\"\"Yield successive m-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), m):\n        yield lst[i:i + m]\n```\n:::\n\n\nVérifier le fonctionnement de `naive_par`\n\n::: {#4ed80ffb .cell tags='[\"solution\"]' execution_count=17}\n``` {.python .cell-code}\ndef naive_par(lst,n):\n    return chunks(lst,int(len(lst)/n))\n```\n:::\n\n\n::: {#55dba53d .cell tags='[\"solution\"]' execution_count=18}\n``` {.python .cell-code}\nlist(naive_par(range(1,100001),4))\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[range(1, 25001),\n range(25001, 50001),\n range(50001, 75001),\n range(75001, 100001)]\n```\n:::\n:::\n\n\n::: {#127bde26 .cell tags='[\"solution\"]' execution_count=19}\n``` {.python .cell-code}\ndef multi_process_list(f,n,par_f,l):\n    with Pool(n) as pool:\n        return sum(pool.map(f,par_f(l,n)))\n```\n:::\n\n\n::: {#5a637934 .cell tags='[\"solution\"]' execution_count=20}\n``` {.python .cell-code}\nmulti_process_list(total_primes,ncores,naive_par,range(1,N+1))\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n9593\n```\n:::\n:::\n\n\n::: {#a338f6fe .cell execution_count=21}\n``` {.python .cell-code}\nmulti_time = %timeit -o multi_process_list(total_primes,ncores,naive_par,range(1,N+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n44.2 ms ± 776 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n:::\n:::\n\n\n::: {#f826bcb9 .cell execution_count=22}\n``` {.python .cell-code}\nprint(\"Gain avec multi : {:.1f}\".format(orig_time.average/multi_time.average))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGain avec multi : 1.6\n```\n:::\n:::\n\n\nRepeat all calculations and payoff comparisons with $N=5000000$. To avoid long calculation times, we'll restrict ourselves to a single iteration (option `-r 1 -n 1` in `%timeit`).\n\n::: {#7acd1c9d .cell execution_count=23}\n``` {.python .cell-code}\nN = 5000000\n```\n:::\n\n\n::: {#f753b824 .cell execution_count=24}\n``` {.python .cell-code}\norig_time = %timeit -r 1 -n 1 -o total_primes(range(1,N+1))\nsplit_time = %timeit -r 1 -n 1 -o split_total(N)\nmulti_time = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,range(1,N+1))\n\nprint(\"Gain with split : {:.1f}\".format(orig_time.average/split_time.average))\nprint(\"Gain with multi : {:.1f}\".format(orig_time.average/multi_time.average))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n18.4 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n11.4 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n3.24 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\nGain with split : 1.6\nGain with multi : 5.7\n```\n:::\n:::\n\n\n# Optional refinement\n\n\nHow much time is spent on each task? Use the following function to get an idea. What do you observe?\n\n::: {#14491883 .cell execution_count=25}\n``` {.python .cell-code}\ndef timed_total_primes(l):\n    %timeit -r 1 -n 1 total_primes(l)\n    return 0\n```\n:::\n\n\n::: {#86c887fc .cell tags='[\"solution\"]' execution_count=26}\n``` {.python .cell-code}\nmulti_process_list(timed_total_primes,ncores,naive_par,range(1,N+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n914 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n1.57 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n2.01 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n2.28 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n2.53 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n2.75 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n2.96 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n3.13 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0\n```\n:::\n:::\n\n\nHow can we solve this problem?\n\nFind a simple solution that requires only one line of code. Check the execution times of individual tasks.\n\nCompare again with $N = 10000000$ (which will take about 1 minute sequentially).\n\n::: {#7283a09a .cell tags='[\"solution\"]' execution_count=27}\n``` {.python .cell-code}\nimport random\n\nN = 10000000\n\nshuffled = random.sample(range(1,N+1),N)\n```\n:::\n\n\n::: {#6faa9636 .cell tags='[\"solution\"]' execution_count=28}\n``` {.python .cell-code}\nmulti_process_list(total_primes,ncores,naive_par,shuffled)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n664580\n```\n:::\n:::\n\n\n::: {#795c55b2 .cell tags='[\"solution\"]' execution_count=29}\n``` {.python .cell-code}\ntemps_shuffled = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,shuffled)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7.76 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n:::\n\n\n::: {#aa78e792 .cell tags='[\"solution\"]' execution_count=30}\n``` {.python .cell-code}\nmulti_process_list(timed_total_primes,ncores,naive_par,shuffled)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.99 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.08 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.06 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.09 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.08 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.04 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.03 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n6.18 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n0\n```\n:::\n:::\n\n\n::: {#e3f266df .cell tags='[\"solution\"]' execution_count=31}\n``` {.python .cell-code}\nshuffled = random.sample(range(1,N+1),N)\norig_time = %timeit -r 1 -n 1 -o total_primes(range(1,N+1))\nmulti_time = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,range(1,N+1))\nshuffled_time = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,shuffled)\n\nprint(\"Gain with multi : {:.1f}\".format(orig_time.average/multi_time.average))\nprint(\"Gain with shuffled : {:.1f}\".format(orig_time.average/shuffled_time.average))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n55.2 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n8.43 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n7.74 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\nGain with multi : 6.6\nGain with shuffled : 7.1\n```\n:::\n:::\n\n\n# Recreational interlude\n\nIf you have a CPU with SMT (Hyperthreading), redo the measurements with `ncores` equal to the number of logic cores, and explain the results.\n\n::: {#0daa1420 .cell tags='[\"solution\"]' execution_count=32}\n``` {.python .cell-code}\nncores = 8 # On a machine with 4 physical cores/8 logical cores\n\nshuffled = random.sample(range(1,N+1),N)\norig_time = %timeit -r 1 -n 1 -o total_primes(range(1,N+1))\nmulti_time = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,range(1,N+1))\nshuffled_time = %timeit -r 1 -n 1 -o multi_process_list(total_primes,ncores,naive_par,shuffled)\n\nprint(\"Gain with multi : {:.1f}\".format(orig_time.average/multi_time.average))\nprint(\"Gain with shuffled : {:.1f}\".format(orig_time.average/shuffled_time.average))\n```\n:::\n\n\n:::{.solution-box}\n\nThis has been run on a machine with 4 physical cores and 8 logical cores, \n[Intel Xeon CPU E5-1620 v4](https://www.intel.com/content/www/us/en/products/sku/92991/intel-xeon-processor-e51620-v4-10m-cache-3-50-ghz/specifications.html).\n\nThe results show that the gain is less than with 4 physical cores. This is because the logical cores share the same physical core, and the overhead of sharing the same physical core is greater than the gain from parallelization.\n\n\n\n\n{{< embed ../Solutions/1_1_MultiProcessing-smt-sol.ipynb#smt-example >}}\n\n\n\n\n\n\n:::\n\n",
    "supporting": [
      "1_1_MultiProcessing-sol_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}