{
  "hash": "6b01090c8aad5f6695f7158fdf4b7164",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An `asyncio` application\"\n---\n\n\n## Simple *Hello world* example\n\nJust make an asyncio coroutine which displays *Hello* and *world* with a 1 second delay in between and then await it.\n\n::: {#4cec6a1b .cell tags='[\"solution\"]' execution_count=2}\n``` {.python .cell-code}\nimport asyncio\n\n\nasync def hello():\n    print(\"Hello\")\n    await asyncio.sleep(1)\n    print(\"world\")\n\n\nawait hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nworld\n```\n:::\n:::\n\n\n## `asyncio` queues\n\n[Official doc](https://docs.python.org/3/library/asyncio-queue.html)\n\n> asyncio queues are designed to be similar to classes of the queue module. Although asyncio queues are not thread-safe, they are designed to be used specifically in async/await code.\n> Note that methods of asyncio queues don’t have a timeout parameter; use asyncio.wait_for() function to do queue operations with a timeout.\n\nwe have `put`/`get` coroutines for the queue.\n\n## `asyncio` queues example\n\n::: {#faaa9eba .cell execution_count=3}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nawait queue.put(1)\nawait queue.put(2)\n\nprint(await queue.get())\nprint(await queue.get())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n```\n:::\n:::\n\n\n# Producer/Consumer example\n\n![](../figs/producer-consumer.png)\n\n- We want to produce, asynchronously, a sequence of integers and consume them as they are produced, also asynchronously.\n- Producing and consuming are two separate tasks, communicating through a queue.\n- We’ll arbitrarily slow down the producer by sleeping 1 second for each produced item.\n\nThe producer, once finished will produce a `None` in the queue, so that the consumer knows it’s done.\n\n## Pure `asyncio` solution\n\n::: {#328fd509 .cell execution_count=4}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nasync def produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\n\nasync def consume():\n    print(\"consuming items\")\n    consumed = 0\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nres = . . .\nres\n```\n:::\n\n\n::: {#33903f4d .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\nimport asyncio\n\nqueue = asyncio.Queue()\n\nasync def produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        await asyncio.sleep(1)\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        await queue.put(item)\n\n    # indicate the producer is done\n    await queue.put(None)\n    return n\n\n\nasync def consume():\n    print(\"consuming items\")\n    consumed = 0\n    while True:\n        # wait for an item from the producer\n        item = await queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        print(\"consuming {}\".format(item))\n        # simulate i/o operation using sleep\n        consumed += 1\n    return consumed\n\nres = await asyncio.gather(\n    produce(10),\n    consume()\n)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## The same with threads\n\n:::{.callout-caution }\nThreads doesn’t run coroutines directly. We need to use [`run_coroutine_threadsafe(coroutine,loop)`](https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe) to run a coroutine in a thread, dispatching it to the event loop. It returns a `Future` object that we can use to wait for the result of the coroutine.\n:::\n\nFor thread-safe queues, we can use the `queue` module from the standard library (not `asyncio.Queue`).\n\n::: {#0f5f1d55 .cell execution_count=6}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\nfrom queue import Queue\n\nqueue = Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\ndef consume():\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ThreadPoolExecutor() as pool:\n    res = . . .\nres\n```\n:::\n\n\n::: {#a5bac701 .cell tags='[\"solution\"]' execution_count=7}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\nfrom queue import Queue\n\nqueue = Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        future = asyncio.run_coroutine_threadsafe(asyncio.sleep(1), loop)\n        future.result()\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        queue.put(item)\n\n    # indicate the producer is done\n    queue.put(None)\n    return n\n\ndef consume():\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        item = queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ThreadPoolExecutor() as pool:\n    res = await asyncio.gather(\n        loop.run_in_executor(pool, functools.partial(produce, 10)),\n        loop.run_in_executor(pool, functools.partial(consume))\n    )\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## The same with processes\n\nThe queue is now a `multiprocessing.Queue`.\n\nFirst do it normally, like previous example, observe the output.\n    \nThen add a `Lock` to protect the `print` statements.\n\nThe sleep is now a Python `sleep` (not `asyncio.sleep`).\n\n```python\n#| eval: false\nlock = Lock()\n\n# inside a task\nwith lock:\n    print(\"foo bar\")\n```\n\n::: {#26b0271c .cell execution_count=8}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ProcessPoolExecutor\nimport asyncio\nfrom multiprocessing import Manager, Lock\nfrom time import sleep\n\nmanager = Manager()\nqueue = manager.Queue()\nloop = asyncio.get_running_loop()\n\ndef produce(queue, n):\n    print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        . . .\n        # produce an item\n        print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        . . .\n\n    # indicate the producer is done\n    . . .\n    return n\n\n\ndef consume(queue):\n    consumed = 0\n    print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        . . .\n        # Handle the end of the production\n        . . .\n        # process the item\n        print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ProcessPoolExecutor() as pool:\n    res = . . .\nres\n```\n:::\n\n\n::: {#3c4cea4f .cell tags='[\"solution\"]' execution_count=9}\n``` {.python .cell-code}\nimport functools\nfrom concurrent.futures import ProcessPoolExecutor\nimport asyncio\nfrom multiprocessing import Manager, Lock\nfrom time import sleep\n\nmanager = Manager()\nqueue = manager.Queue()\nloop = asyncio.get_running_loop()\nlock = Lock()\n\ndef produce(queue, n):\n    with lock:\n        print(\"producing {} items\".format(n))\n    for x in range(1, n + 1):\n        # simulate i/o operation using sleep\n        sleep(1)\n        # produce an item\n        with lock:\n            print(\"producing {}/{}\".format(x, n))\n        item = str(x)\n        # put the item in the queue\n        queue.put(item)\n\n    # indicate the producer is done\n    queue.put(None)\n    return n\n\n\ndef consume(queue):\n    consumed = 0\n    with lock:\n        print(\"consuming items\")\n    while True:\n        # wait for an item from the producer\n        item = queue.get()\n        if item is None:\n            # the producer emits None to indicate that it is done\n            break\n\n        # process the item\n        with lock:\n            print(\"consuming {}\".format(item))\n        consumed += 1\n    return consumed\n\nwith ProcessPoolExecutor() as pool:\n    res = await asyncio.gather(\n        loop.run_in_executor(pool, functools.partial(produce, queue, 10)),\n        loop.run_in_executor(pool, functools.partial(consume, queue))\n    )\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nproducing 10 items\nconsuming items\nproducing 1/10\nconsuming 1\nproducing 2/10\nconsuming 2\nproducing 3/10\nconsuming 3\nproducing 4/10\nconsuming 4\nproducing 5/10\nconsuming 5\nproducing 6/10\nconsuming 6\nproducing 7/10\nconsuming 7\nproducing 8/10\nconsuming 8\nproducing 9/10\nconsuming 9\nproducing 10/10\nconsuming 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[10, 10]\n```\n:::\n:::\n\n\n## Exception Handling\n\n**See also**\n\n* [set_exception_handler](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.set_exception_handler)\n\n\n```python\ndef main():\n    loop = asyncio.get_event_loop()\n    # May want to catch other signals too\n    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)\n    for s in signals:\n        loop.add_signal_handler(\n            s, lambda s=s: asyncio.create_task(shutdown(loop, signal=s))\n        )\n    loop.set_exception_handler(handle_exception)\n    queue = asyncio.Queue()\n```\n\n## Testing with `pytest`\n\n### Example:\n\n```python\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_consume(mock_get, mock_queue, message, create_mock_coro):\n    mock_get.side_effect = [message, Exception(\"break while loop\")]\n\n    with pytest.raises(Exception, match=\"break while loop\"):\n        await consume(mock_queue)\n```\n\n### Third-party libraries\n\n* [pytest-asyncio](https://github.com/pytest-dev/pytest-asyncio) has helpfull things like fixtures for `event_loop`, `unused_tcp_port`, and `unused_tcp_port_factory`; and the ability to create your own [asynchronous fixtures](https://github.com/pytest-dev/pytest-asyncio/#async-fixtures).\n* [asynctest](https://asynctest.readthedocs.io/en/latest/index.html) has helpful tooling, including coroutine mocks and [exhaust_callbacks](https://asynctest.readthedocs.io/en/latest/asynctest.helpers.html#asynctest.helpers.exhaust_callbacks) so we don’t have to manually await tasks.\n* [aiohttp](https://docs.aiohttp.org/en/stable/) has some really nice built-in test utilities.\n\n## Debugging\n\n`asyncio` already has a [debug mode](https://docs.python.org/3.6/library/asyncio-dev.html#debug-mode-of-asyncio) in the standard library. You can simply activate it with the `PYTHONASYNCIODEBUG` environment variable or in the code with `loop.set_debug(True)`.\n\n### Using the debug mode to identify slow async calls\n\n`asyncio`’s debug mode has a tiny built-in profiler. When debug mode is on, `asyncio` will log any asynchronous calls that take longer than 100 milliseconds.\n\n### Debugging in oroduction with `aiodebug`\n\n[aiodebug](https://github.com/qntln/aiodebug) is a tiny library for monitoring and testing asyncio programs.\n\n#### Example\n\n```python\nfrom aiodebug import log_slow_callbacks\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    log_slow_callbacks.enable(0.05)\n```\n\n## Logging\n\n[aiologger](https://github.com/b2wdigital/aiologger) allows non-blocking logging.\n\n## Asynchronous Widgets\n\n**See also**\n\n* [Asynchronous Widgets](https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Asynchronous.html)\n\n::: {#97a85424 .cell execution_count=10}\n``` {.python .cell-code}\ndef wait_for_change(widget, value):\n    future = asyncio.Future()\n\n    def getvalue(change):\n        # make the new value available\n        future.set_result(change.new)\n        widget.unobserve(getvalue, value)\n\n    widget.observe(getvalue, value)\n    return future\n```\n:::\n\n\n::: {#d3b8233a .cell execution_count=11}\n``` {.python .cell-code}\nfrom ipywidgets import IntSlider\n\n\nslider = IntSlider()\n\n\nasync def f():\n    for i in range(10):\n        print(\"did work %s\" % i)\n        x = await wait_for_change(slider, \"value\")\n        print(\"async function continued with value %s\" % x)\n\n\nasyncio.create_task(f())\n\nslider\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{.json}\n{\"model_id\":\"44f6848381de40f08f3a9118cbf3fe73\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n```\n:::\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /nfs/home/collinf/micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n  widgets: eyJhcHBsaWNhdGlvbi92bmQuanVweXRlci53aWRnZXQtc3RhdGUranNvbiI6eyJzdGF0ZSI6eyIwYzYzOTMzYTczN2I0MDQ0YmU5Zjg3Zjc2MjA2YzFmMiI6eyJtb2RlbF9tb2R1bGUiOiJAanVweXRlci13aWRnZXRzL2Jhc2UiLCJtb2RlbF9tb2R1bGVfdmVyc2lvbiI6IjIuMC4wIiwibW9kZWxfbmFtZSI6IkxheW91dE1vZGVsIiwic3RhdGUiOnsiX21vZGVsX21vZHVsZSI6IkBqdXB5dGVyLXdpZGdldHMvYmFzZSIsIl9tb2RlbF9tb2R1bGVfdmVyc2lvbiI6IjIuMC4wIiwiX21vZGVsX25hbWUiOiJMYXlvdXRNb2RlbCIsIl92aWV3X2NvdW50IjpudWxsLCJfdmlld19tb2R1bGUiOiJAanVweXRlci13aWRnZXRzL2Jhc2UiLCJfdmlld19tb2R1bGVfdmVyc2lvbiI6IjIuMC4wIiwiX3ZpZXdfbmFtZSI6IkxheW91dFZpZXciLCJhbGlnbl9jb250ZW50IjpudWxsLCJhbGlnbl9pdGVtcyI6bnVsbCwiYWxpZ25fc2VsZiI6bnVsbCwiYm9yZGVyX2JvdHRvbSI6bnVsbCwiYm9yZGVyX2xlZnQiOm51bGwsImJvcmRlcl9yaWdodCI6bnVsbCwiYm9yZGVyX3RvcCI6bnVsbCwiYm90dG9tIjpudWxsLCJkaXNwbGF5IjpudWxsLCJmbGV4IjpudWxsLCJmbGV4X2Zsb3ciOm51bGwsImdyaWRfYXJlYSI6bnVsbCwiZ3JpZF9hdXRvX2NvbHVtbnMiOm51bGwsImdyaWRfYXV0b19mbG93IjpudWxsLCJncmlkX2F1dG9fcm93cyI6bnVsbCwiZ3JpZF9jb2x1bW4iOm51bGwsImdyaWRfZ2FwIjpudWxsLCJncmlkX3JvdyI6bnVsbCwiZ3JpZF90ZW1wbGF0ZV9hcmVhcyI6bnVsbCwiZ3JpZF90ZW1wbGF0ZV9jb2x1bW5zIjpudWxsLCJncmlkX3RlbXBsYXRlX3Jvd3MiOm51bGwsImhlaWdodCI6bnVsbCwianVzdGlmeV9jb250ZW50IjpudWxsLCJqdXN0aWZ5X2l0ZW1zIjpudWxsLCJsZWZ0IjpudWxsLCJtYXJnaW4iOm51bGwsIm1heF9oZWlnaHQiOm51bGwsIm1heF93aWR0aCI6bnVsbCwibWluX2hlaWdodCI6bnVsbCwibWluX3dpZHRoIjpudWxsLCJvYmplY3RfZml0IjpudWxsLCJvYmplY3RfcG9zaXRpb24iOm51bGwsIm9yZGVyIjpudWxsLCJvdmVyZmxvdyI6bnVsbCwicGFkZGluZyI6bnVsbCwicmlnaHQiOm51bGwsInRvcCI6bnVsbCwidmlzaWJpbGl0eSI6bnVsbCwid2lkdGgiOm51bGx9fSwiMmYyNmQwNGU5MWQ5NGY5MTg4NjFkNjI2MWY4YTg1MDMiOnsibW9kZWxfbW9kdWxlIjoiQGp1cHl0ZXItd2lkZ2V0cy9jb250cm9scyIsIm1vZGVsX21vZHVsZV92ZXJzaW9uIjoiMi4wLjAiLCJtb2RlbF9uYW1lIjoiU2xpZGVyU3R5bGVNb2RlbCIsInN0YXRlIjp7Il9tb2RlbF9tb2R1bGUiOiJAanVweXRlci13aWRnZXRzL2NvbnRyb2xzIiwiX21vZGVsX21vZHVsZV92ZXJzaW9uIjoiMi4wLjAiLCJfbW9kZWxfbmFtZSI6IlNsaWRlclN0eWxlTW9kZWwiLCJfdmlld19jb3VudCI6bnVsbCwiX3ZpZXdfbW9kdWxlIjoiQGp1cHl0ZXItd2lkZ2V0cy9iYXNlIiwiX3ZpZXdfbW9kdWxlX3ZlcnNpb24iOiIyLjAuMCIsIl92aWV3X25hbWUiOiJTdHlsZVZpZXciLCJkZXNjcmlwdGlvbl93aWR0aCI6IiIsImhhbmRsZV9jb2xvciI6bnVsbH19LCI0NGY2ODQ4MzgxZGU0MGYwOGYzYTkxMThjYmYzZmU3MyI6eyJtb2RlbF9tb2R1bGUiOiJAanVweXRlci13aWRnZXRzL2NvbnRyb2xzIiwibW9kZWxfbW9kdWxlX3ZlcnNpb24iOiIyLjAuMCIsIm1vZGVsX25hbWUiOiJJbnRTbGlkZXJNb2RlbCIsInN0YXRlIjp7Il9kb21fY2xhc3NlcyI6W10sIl9tb2RlbF9tb2R1bGUiOiJAanVweXRlci13aWRnZXRzL2NvbnRyb2xzIiwiX21vZGVsX21vZHVsZV92ZXJzaW9uIjoiMi4wLjAiLCJfbW9kZWxfbmFtZSI6IkludFNsaWRlck1vZGVsIiwiX3ZpZXdfY291bnQiOm51bGwsIl92aWV3X21vZHVsZSI6IkBqdXB5dGVyLXdpZGdldHMvY29udHJvbHMiLCJfdmlld19tb2R1bGVfdmVyc2lvbiI6IjIuMC4wIiwiX3ZpZXdfbmFtZSI6IkludFNsaWRlclZpZXciLCJiZWhhdmlvciI6ImRyYWctdGFwIiwiY29udGludW91c191cGRhdGUiOnRydWUsImRlc2NyaXB0aW9uIjoiIiwiZGVzY3JpcHRpb25fYWxsb3dfaHRtbCI6ZmFsc2UsImRpc2FibGVkIjpmYWxzZSwibGF5b3V0IjoiSVBZX01PREVMXzBjNjM5MzNhNzM3YjQwNDRiZTlmODdmNzYyMDZjMWYyIiwibWF4IjoxMDAsIm1pbiI6MCwib3JpZW50YXRpb24iOiJob3Jpem9udGFsIiwicmVhZG91dCI6dHJ1ZSwicmVhZG91dF9mb3JtYXQiOiJkIiwic3RlcCI6MSwic3R5bGUiOiJJUFlfTU9ERUxfMmYyNmQwNGU5MWQ5NGY5MTg4NjFkNjI2MWY4YTg1MDMiLCJ0YWJiYWJsZSI6bnVsbCwidG9vbHRpcCI6bnVsbCwidmFsdWUiOjB9fX0sInZlcnNpb25fbWFqb3IiOjIsInZlcnNpb25fbWlub3IiOjB9fQ==\n---\n",
    "supporting": [
      "3_Asynchronous_files/figure-ipynb"
    ],
    "filters": []
  }
}