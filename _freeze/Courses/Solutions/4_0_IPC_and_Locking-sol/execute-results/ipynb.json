{
  "hash": "a47bf05402eed6c4b6f6be39a11af149",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"IPC and Locking\"\n---\n\n\n# Streaming (pipelining) data\n\nSticking to our favorite hobby, which is finding prime numbers, this time, we'll use a different strategy.\n\nInstead of partitioning the data from scratch, we will continuously *feed* workers from our multiprocessing pool with small size chunk of numbers and the workers send us back the the primes they found on those chunks.\n\nWe need two queues : one for the chunks of numbers that's the *INPUT*\n\nAnother one for the results sent that's the *OUTPUT*\n\n<pre style=\"font-size:0.4em\">\n                                                              ┌──────────────┐\n                                                              │              │\n                                                              │              │\n                           ┌─────────────────────────────────►│   Worker 1   ├───────────────────────────────────┐\n                           │                                  │              │                                   │\n                           │                                  │              │                                   │\n                           │                                  └──────────────┘                                   │\n                           │                                                                                     │\n                           │                                  ┌──────────────┐                                   │\n                           │                                  │              │                                   │\n                           │                                  │              │                                   │\n                           │                    ┌────────────►│   Worker 2   ├───────────────────────────────────┼────────────────────┐\n                           │                    │             │              │                                   │                    │\n                           │                    │             │              │                                   │                    │\n              ┌──────┐  ┌──┴───┐  ┌──────┐  ┌───┴──┐          └──────────────┘                      ┌──────┐  ┌──▼───┐  ┌──────┐  ┌───▼──┐\n...           │Chunk4│  │Chunk3│  │Chunk2│  │Chunk1│                                 ...            │Res. 4│  │Res. 3│  │Res. 2│  │Res. 1│\n              └───┬──┘  └──────┘  └───┬──┘  └──────┘          ┌──────────────┐                      └───▲──┘  └──────┘  └───▲──┘  └──────┘\n                  │                   │                       │              │                          │                   │\n                  │                   │                       │              │                          │                   │\n                  │                   └──────────────────────►│   Worker 3   ├──────────────────────────┼───────────────────┘\n                  │                                           │              │                          │\n                  │                                           │              │                          │\n                  │                                           └──────────────┘                          │\n                  │                                                                                     │\n                  │                                           ┌──────────────┐                          │\n                  │                                           │              │                          │\n                  │                                           │              │                          │\n                  └──────────────────────────────────────────►│   Worker 4   ├──────────────────────────┘\n                                                              │              │\n                                                              │              │\n       ──────────────────────────────────────────►            └──────────────┘               ──────────────────────────────────────────►\n\n                      INPUT                                                                               OUTPUT\n</pre>\n\nLet's revive our old `check_prime` function back from the dead...\n\n::: {#a47569a3 .cell execution_count=2}\n``` {.python .cell-code}\nimport math\n\ndef check_prime(n):\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n```\n:::\n\n\nLet's get back the chunk generator, too.\n\n::: {#279dfa2f .cell execution_count=3}\n``` {.python .cell-code}\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n```\n:::\n\n\nNow we want to use a *producer/consumer* model, where each process got :\n\n- an _input_ queue for receiving chunks of numbers\n- an _output_ queue for sending back a list of all primes found in the _input_ queue.\n\nBoth _input_ and _output_ elements are *lists* (or even python iterables for the input). \nWe'll use `None` as a terminating element in the queue.\n\n## Queue Worker Function\n\nCreate a *worker* function, which takes as the _input_ and _output_ queues as argument. \n\nFor each element in the _input_ queue, which is a list of numbers, get the primes (as a list).\nPut the list of found primes to the _output_ queue.\n\n```python\ndef find_prime_worker(input, output):\n    for chunk in iter(input.get,None):\n        primes_found = ...\n        output.put(primes_found)\n```\n\n## Test  the worker function\n\n1. Manually allocate the _input_ and _output_ queues (we use managed queues)\n2. Put some chunks of numbers in the _input_ queue (don't forget to terminate the queue with `None`)\n3. Launch the worker function on the queues and terminate the output queue with `None`.\n4. Collect the results in a unified list.\n\n## Some Tools\n\n### Iterate on a queue\n\nTo make a queue terminated by `None` iterable use the [`iter`](https://docs.python.org/3/library/functions.html#iter) function : \n```python\niter(queue.get,None)\n```\n\n### Collect a list of list\n\n\nTo collect a list of list use the [`chain`](https://docs.python.org/3/library/itertools.html#itertools.chain) function from `itertools` :\n```python\nchain(*list_of_list)\n```\n\n### Reminder\n\nIterables are lazy in python, to actually make a list you have to force a `list()` of them.\n```python\nlist(iterables)\n```\n\n### Worker function\n\n::: {#b65a5ecc .cell tags='[\"solution\"]' execution_count=4}\n``` {.python .cell-code}\ndef find_prime_worker(input, output):\n    for chunk in iter(input.get,None):\n        primes_found = list(filter(check_prime,chunk))\n        output.put(primes_found)     \n    return\n```\n:::\n\n\n### 1. Allocations\n\n::: {#4429acb9 .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\nfrom multiprocessing import Manager\n\nmanager = Manager()\ninput = manager.Queue()\noutput = manager.Queue()\n```\n:::\n\n\n### 2. Some chunk in the input\n\n::: {#c9c9984b .cell tags='[\"solution\"]' execution_count=6}\n``` {.python .cell-code}\ninput.put(range(2,100))\ninput.put(range(1000,2000))\ninput.put(None)\n```\n:::\n\n\n### 3. Launch the worker and terminate the output\n\n::: {#7730faba .cell tags='[\"solution\"]' execution_count=7}\n``` {.python .cell-code}\nfind_prime_worker(input,output)\noutput.put(None)\n```\n:::\n\n\n### 4. Collect the results\n\n::: {#1e7c1083 .cell tags='[\"solution\"]' execution_count=8}\n``` {.python .cell-code}\nfrom itertools import chain\n\nlist(chain(*list(iter(output.get,None))))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n[3,\n 5,\n 7,\n 11,\n 13,\n 17,\n 19,\n 23,\n 29,\n 31,\n 37,\n 41,\n 43,\n 47,\n 53,\n 59,\n 61,\n 67,\n 71,\n 73,\n 79,\n 83,\n 89,\n 97,\n 1009,\n 1013,\n 1019,\n 1021,\n 1031,\n 1033,\n 1039,\n 1049,\n 1051,\n 1061,\n 1063,\n 1069,\n 1087,\n 1091,\n 1093,\n 1097,\n 1103,\n 1109,\n 1117,\n 1123,\n 1129,\n 1151,\n 1153,\n 1163,\n 1171,\n 1181,\n 1187,\n 1193,\n 1201,\n 1213,\n 1217,\n 1223,\n 1229,\n 1231,\n 1237,\n 1249,\n 1259,\n 1277,\n 1279,\n 1283,\n 1289,\n 1291,\n 1297,\n 1301,\n 1303,\n 1307,\n 1319,\n 1321,\n 1327,\n 1361,\n 1367,\n 1373,\n 1381,\n 1399,\n 1409,\n 1423,\n 1427,\n 1429,\n 1433,\n 1439,\n 1447,\n 1451,\n 1453,\n 1459,\n 1471,\n 1481,\n 1483,\n 1487,\n 1489,\n 1493,\n 1499,\n 1511,\n 1523,\n 1531,\n 1543,\n 1549,\n 1553,\n 1559,\n 1567,\n 1571,\n 1579,\n 1583,\n 1597,\n 1601,\n 1607,\n 1609,\n 1613,\n 1619,\n 1621,\n 1627,\n 1637,\n 1657,\n 1663,\n 1667,\n 1669,\n 1693,\n 1697,\n 1699,\n 1709,\n 1721,\n 1723,\n 1733,\n 1741,\n 1747,\n 1753,\n 1759,\n 1777,\n 1783,\n 1787,\n 1789,\n 1801,\n 1811,\n 1823,\n 1831,\n 1847,\n 1861,\n 1867,\n 1871,\n 1873,\n 1877,\n 1879,\n 1889,\n 1901,\n 1907,\n 1913,\n 1931,\n 1933,\n 1949,\n 1951,\n 1973,\n 1979,\n 1987,\n 1993,\n 1997,\n 1999]\n```\n:::\n:::\n\n\n# Putting the workers to... work.\n\nmake a function which allocates the queues, and use a `Pool(ncore)` of worker.\n\n```python\ndef calculate_primes(ncore,N,chunksize):\n    ...\n```\n\n- `ncore` is the number of workers (and will be aligned with the number of cores you got, 8 for example)\n- `N` is the upper limit of the primes we want to find \n- `chunksize` is the size of the chunks we'll send to process to workers.\n\n## The main process\n\n1. First we'll use a [`starmap_async`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.starmap_async) for our main dispatcher function (don't use the `chunksize` optional argument of the function) \n2. Feed the input queue with all chunks from the `chunks(range(1,N),chunksize)`\n3. Terminate the _input_ queue (`ncores * None`, one for each worker)\n4. Wait for the workers to finish\n5. Collect and return the results\n\nTest and benchmark it on a `int(N/64)` chunk size\n```python\nN = 5000000\n```\n\n## Solution for main process function\n\n::: {#95464eb0 .cell tags='[\"solution\"]' execution_count=9}\n``` {.python .cell-code}\nfrom multiprocessing import Pool,Manager\nfrom itertools import chain\n\ndef calculate_primes(ncore,N,chunksize):\n    with Manager() as manager:\n        input = manager.Queue()\n        output = manager.Queue()\n\n        with Pool(ncore) as p:\n            it = p.starmap_async(find_prime_worker,[(input,output)]*ncore)\n            for r in chunks(range(1,N),chunksize):\n                input.put(r)\n            for i in range(ncore): input.put(None)\n            it.wait()\n            output.put(None)\n\n        res = list(chain(*list(iter(output.get,None))))\n    return res\n```\n:::\n\n\n### Test of the main function\n\n::: {#4e90cc49 .cell execution_count=10}\n``` {.python .cell-code}\nN = 5000000\n```\n:::\n\n\n::: {#0fb5b895 .cell tags='[\"solution\"]' execution_count=11}\n``` {.python .cell-code}\n%timeit -r 1 -n 1 calculate_primes(4,N,int(N/64))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.71 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n:::\n\n\n## Autosizing chunks ! (optional)\n\nWe know that greater the number is, longer it is to check if it is a prime.\n\nA slight optimization to our multi-processing/queued algorithm is to make the chunks smaller and smaller with greater numbers chunks.\n\n1. Try to modify the `chunks` function to take this into account, test the function.\n2. Modify the `calculate_primes_chunks` to use this function\n3. Test and benchmark it.\n\n###  autosizing chunks example function\n\n::: {#8e6b9de9 .cell tags='[\"solution\"]' execution_count=12}\n``` {.python .cell-code}\ndef chunks_rsquared(lst, n):\n    \"\"\"Yield successive n-sized chunks with n recursively root-squared.\"\"\"\n    i = 0\n    while (i < len(lst)):\n        yield lst[i:i + n]\n        i = i + n\n        n = max(1,int(n*0.8))\n```\n:::\n\n\n### Test it\n\n::: {#32db1c67 .cell tags='[\"solution\"]' execution_count=13}\n``` {.python .cell-code}\nlist(chunks_rsquared(range(1,N),int(N/4)))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n[range(1, 1250001),\n range(1250001, 2250001),\n range(2250001, 3050001),\n range(3050001, 3690001),\n range(3690001, 4202001),\n range(4202001, 4611601),\n range(4611601, 4939281),\n range(4939281, 5000000)]\n```\n:::\n:::\n\n\n### Modify the main worker process function\n\n::: {#65cb1159 .cell tags='[\"solution\"]' execution_count=14}\n``` {.python .cell-code}\ndef calculate_primes_chunks_rsquared(ncore,N,chunksize):\n    with Manager() as manager:\n        input = manager.Queue()\n        output = manager.Queue()\n\n        with Pool(ncore) as p:\n            it = p.starmap_async(find_prime_worker,[(input,output)]*ncore)\n            for r in chunks_rsquared(range(1,N),chunksize):\n                input.put(r)\n            for i in range(ncore): input.put(None)\n            it.wait()\n            output.put(None)\n\n        res = list(chain(*list(iter(output.get,None))))\n    return res\n```\n:::\n\n\n### Test and benchmark it\n\n::: {#5652c63b .cell tags='[\"solution\"]' execution_count=15}\n``` {.python .cell-code}\n%timeit -r 1 -n 1 calculate_primes_chunks_rsquared(4,N,int(N/4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.92 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /storage/simple/users/collinf/micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n---\n",
    "supporting": [
      "4_0_IPC_and_Locking-sol_files/figure-ipynb"
    ],
    "filters": []
  }
}