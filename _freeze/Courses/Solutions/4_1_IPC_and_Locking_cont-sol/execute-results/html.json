{
  "hash": "26a9030458ed6c30beed55d4a3142c6f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Locking with `multiprocessing.Value`\n---\n\n\n\n\nTake look at [Python Documentation on `multiprocessing.Value`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value)\n\nWrite a simple worker fonction which takes a `multiprocessing.Value` and a `max_count` argument, and increment the value by one `max_count` times:\n\n```python\nimport multiprocessing\n\ndef work(value, max_count):\n    ...\n```\n\n::: {#4ce1e5f1 .cell tags='[\"solution\"]' execution_count=2}\n``` {.python .cell-code}\nimport multiprocessing\n\ndef work(value, max_count):\n    for n in range(max_count):\n        value.value += 1\n```\n:::\n\n\n1. Write a main function instantiating an integer `multiprocessing.Value` initialized to zero and run `ncores` workers incrementing each `N` times the value one by one.\n2. Display the expected final value and the value calculated.\n3. Run it on `(8,100000)` (or even bigger). Replace `8` by the actual number of physical cores on the cpu you’re running on.\n\n```python\ndef run_workers(ncores,N):\n    total_expected_count = ncores * N\n    ...\n```\n\n::: {#c8171972 .cell tags='[\"solution\"]' execution_count=3}\n``` {.python .cell-code}\ndef run_workers(ncores,N):\n    total_expected_count = ncores * N\n    processes = []\n    value = multiprocessing.Value('i', 0)\n    for process_nbr in range(ncores):\n        p = multiprocessing.Process(target=work, args=(value, N))\n        p.start()\n        processes.append(p)\n\n    # wait for the processes to finish\n    for p in processes:\n        p.join()\n\n    # print the final value\n    print(\"Expecting to see a count of {}\".format(total_expected_count))\n    print(\"We have counted to {}\".format(value.value))\n```\n:::\n\n\n:::{.callout-note}\nWe may use a simplified version with `multiprocessing.Pool` and `map` to avoid the manual process management. However, to do so, we have to use the manager version of `multiprocessing.Value` which is (way) slower.\n:::\n\n::: {#45b7c756 .cell tags='[\"solution\"]' execution_count=4}\n``` {.python .cell-code}\nrun_workers(8,100000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpecting to see a count of 800000\nWe have counted to 178574\n```\n:::\n:::\n\n\n## Explanation\n\n1. Disassemble the worker function and try to look where locks occurs, according the reference documentation on `multiprocessing.Value`. The actual loading (resp. storing) of the value are done by `LOAD_ATTR` (resp. `STORE_ATTR`).         \n2. Explain the result\n\n```python\nimport dis\n\ndis.dis(work)\n```\n\n::: {#ba6455e0 .cell tags='[\"solution\"]' execution_count=5}\n``` {.python .cell-code}\nimport dis\n\ndis.dis(work)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  3           0 RESUME                   0\n\n  4           2 LOAD_GLOBAL              1 (NULL + range)\n             12 LOAD_FAST                1 (max_count)\n             14 CALL                     1\n             22 GET_ITER\n        >>   24 FOR_ITER                23 (to 74)\n             28 STORE_FAST               2 (n)\n\n  5          30 LOAD_FAST                0 (value)\n             32 COPY                     1\n             34 LOAD_ATTR                2 (value)\n             54 LOAD_CONST               1 (1)\n             56 BINARY_OP               13 (+=)\n             60 SWAP                     2\n             62 STORE_ATTR               1 (value)\n             72 JUMP_BACKWARD           25 (to 24)\n\n  4     >>   74 END_FOR\n             76 RETURN_CONST             0 (None)\n```\n:::\n:::\n\n\n```plain\n  5          12 LOAD_FAST                0 (value)\n             14 DUP_TOP\n                                                        #<--- Value lock acquired             \n             16 LOAD_ATTR                1 (value)\n                                                        #<--- Value lock released\n             18 LOAD_CONST               1 (1)\n             20 INPLACE_ADD\n             22 ROT_TWO\n                                                        #<--- Value lock acquired\n             24 STORE_ATTR               1 (value)\n                                                        #<--- Value lock released\n             26 JUMP_ABSOLUTE            8\n        >>   28 LOAD_CONST               0 (None)\n             30 RETURN_VALUE\n```\n\nAt instruction 18 (`18 LOAD_CONST`), nothing prevents another process to load the (old) `value` attribute and be on instruction `18` too. Both processes will proceed incrementing their private copy and writing it back. \n\n$\\Rightarrow$ The result: the actual value got incremented only once, not twice.\n\n## Counter measure\n\nNow, propose a solution. Use the reference documentation to modify the `work` function, and the main function.\nTest it.\n\n::: {#58192ebc .cell tags='[\"solution\"]' execution_count=6}\n``` {.python .cell-code}\ndef work_lock(value, max_count):\n    for n in range(max_count):\n        with value.get_lock():\n            value.value += 1\n```\n:::\n\n\n::: {#7200fb92 .cell tags='[\"solution\"]' execution_count=7}\n``` {.python .cell-code}\ndef run_workers_locked(ncores,N):\n    total_expected_count = ncores * N\n    processes = []\n    value = multiprocessing.Value('i', 0)\n    for process_nbr in range(ncores):\n        p = multiprocessing.Process(target=work_lock, args=(value, N))\n        p.start()\n        processes.append(p)\n\n    # wait for the processes to finish\n    for p in processes:\n        p.join()\n\n    # print the final value\n    print(\"Expecting to see a count of {}\".format(total_expected_count))\n    print(\"We have counted to {}\".format(value.value))\n```\n:::\n\n\n::: {#cd32a75d .cell tags='[\"solution\"]' execution_count=8}\n``` {.python .cell-code}\nrun_workers_locked(8,100000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpecting to see a count of 800000\nWe have counted to 800000\n```\n:::\n:::\n\n\n# Optimization\n\nWith the manual locking done now, is the native locking of `multiprocessing.Value` still required ? Explain\n\n:::{.solution}\nAs we already lock the increment operation with both load and store of the value, the fine grained locks of both operation is uneccessary.\n:::\n\nWe now want to use `multiprocessing.RawValue` which is devoid of any lock mechanism, and a manual managed lock from `multiprocessing.manager`.\n\nTake a look at [Python Documentation on `multiprocessing.RawValue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.sharedctypes.RawValue)\n\n1. Write `work_rawlock` and `run_workers_rawlocked`, with careful consideration for where to instatiate the lock.\n2. Test it\n3. Benchmark and compare with the previous, print the speedup.\n\n::: {#efd79bae .cell tags='[\"solution\"]' execution_count=9}\n``` {.python .cell-code}\ndef work_rawlock(value, max_count,lock):\n    for n in range(max_count):\n        with lock:\n            value.value += 1\n```\n:::\n\n\n::: {#ffb28ab6 .cell tags='[\"solution\"]' execution_count=10}\n``` {.python .cell-code}\ndef run_workers_rawlocked(ncores,N):\n    total_expected_count = ncores * N\n    processes = []\n    value = multiprocessing.RawValue('i', 0)\n    lock = multiprocessing.Lock()\n    for process_nbr in range(ncores):\n        p = multiprocessing.Process(target=work_rawlock, args=(value, N, lock))\n        p.start()\n        processes.append(p)\n\n    # wait for the processes to finish\n    for p in processes:\n        p.join()\n\n    # print the final value\n    print(\"Expecting to see a count of {}\".format(total_expected_count))\n    print(\"We have counted to {}\".format(value.value))\n```\n:::\n\n\n::: {#9b228dc9 .cell tags='[\"solution\"]' execution_count=11}\n``` {.python .cell-code}\nrun_workers_rawlocked(8,100000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpecting to see a count of 800000\nWe have counted to 800000\n```\n:::\n:::\n\n\n::: {#c610c116 .cell tags='[\"solution\"]' execution_count=12}\n``` {.python .cell-code}\nlocked_time = %timeit -o -r 1 -n 1 run_workers_locked(4,100000)\nrawlocked_time = %timeit -o -r 1 -n 1 run_workers_rawlocked(4,100000)\n\nprint(\"Gain of multiprocessing.RawValue version : {:.0%}\".format(locked_time.average/rawlocked_time.average) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpecting to see a count of 400000\nWe have counted to 400000\n558 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\nExpecting to see a count of 400000\nWe have counted to 400000\n451 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\nGain of multiprocessing.RawValue version : 124%\n```\n:::\n:::\n\n\n",
    "supporting": [
      "4_1_IPC_and_Locking_cont-sol_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}