{
  "hash": "eeeabe4c02ae818fbb541c7f1a8b48c3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A tutorial on Python generators\"\n---\n\n\n## Generators\n\nA generator is essentially an iterator over an object (say a dataset). You get a small chunk of data obtained through \"iterating over the larger object\" every time you make a call to the generator. Generators might prove to be useful in your implementation of sequential training algorithms where you only require a few samples of your data. For example, in a mini batch stochastic gradient descent, you would need to generate random samples from the dataset for performing an update on your gradient. Generators can be used in such use cases to create memory efficient implementations of your algorithm, since they allow you to perform operations without loading the whole dataset.\n\nAlso see PEP 255 (https://www.python.org/dev/peps/pep-0255/). The explanation presented here is quite thorough.\n\n### Behaviour of generators\n\nA generator behaves like a function with states. Typically, functions in Python do not have any state information. The variables defined within the function scope are reset/destroyed at the end of every function call. A generator allows you store intermediate states between calls, so that every subsequent call can resume from the last state of execution. Generators introduced the `yield` keyword to Python. We will look at a few examples below.\n\n**NOTE**\n\nAlthough generators use the `def` keyword, they are not function objects. Generators are a class in their own right, but are slightly different from function objects.\n\nWe take a look at our first generator.\n\n::: {#0564af6a .cell execution_count=1}\n``` {.python .cell-code}\n## Example from PEP 0255\ndef fib():\n    a, b = 0, 1\n    while 1:\n        yield b\n        a, b = b, a + b\n```\n:::\n\n\nThis is a generator that yields the infinite Fibonnaci sequence. With every call to fib after the first call, the state of the generator gets updated and the value of `b` is returned. \n\nTo use a generator, we first create an instance of the generator. Use the `next` keywork to make calls to the generator. Once a generator has been consumed  completely, a `StopIteration` is raised if you try to consume more elements from the generator.\n\n::: {#27282d15 .cell execution_count=2}\n``` {.python .cell-code}\ngen1 = fib()\n\n# prints the first 10 fibonnaci numbers\nfor i in range(10):\n    print(next(gen1), end=', ')\nprint(\"\\nPassed!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \nPassed!\n```\n:::\n:::\n\n\nThis example shows how you can represent an infinte sequence in Python without using up all the memory in the world. Next, we will look at a more practical example.\n\n::: {#e80262da .cell execution_count=3}\n``` {.python .cell-code}\ndef nsquared(n):\n    while True:\n        yield n ** 2\n        n = n - 1\n        if n == 0:\n            return  # correct way to terminate a generator\n```\n:::\n\n\n::: {#2847d20c .cell execution_count=4}\n``` {.python .cell-code}\ngen2 = nsquared(10)\n\nfor i in gen2:\n    print(i, end=', ')\n\ntry:\n    next(gen2) # should raise a StopIteration exception\nexcept StopIteration:\n    print(\"\\nWe hit the the end of the generator, no more elements can be consumed\")\nexcept Exception as e:\n    print(\"\\nOops! Unexpected error\", e)\nfinally:\n    print(\"Passed !\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100, 81, 64, 49, 36, 25, 16, 9, 4, 1, \nWe hit the the end of the generator, no more elements can be consumed\nPassed !\n```\n:::\n:::\n\n\nNow, suppose you want to find the sum of squares of the first 1,000,000 (1 million) integers. You don't believe the analytical formula and want to calculate it directly by summing up all the requisite squares of integers. It is not memory efficient to create a list of 1 million integers just to compute a sum. This is where our custom generator comes to our rescue.\n\n::: {#1686e362 .cell execution_count=5}\n``` {.python .cell-code}\nsquared_sum1 = sum([i**2 for i in range(1000001)])\nprint(squared_sum1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n333333833333500000\n```\n:::\n:::\n\n\n::: {#afec2937 .cell execution_count=6}\n``` {.python .cell-code}\ngen3 = nsquared(1000000)\nsquared_sum2 = sum(gen3)\nprint(squared_sum2)\n\nassert squared_sum1 == squared_sum1, \"Sums are not equal !\"\nprint(\"Passed !\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n333333833333500000\nPassed !\n```\n:::\n:::\n\n\nAlthough both snippets of code give the same result, the implementation with the generator is more scalable since it uses constant memory. \n\n### Generator expressions\n\nSee PEP 289 (https://www.python.org/dev/peps/pep-0289/).\n\nGenerator expressions merge the concepts of both generators and list comprehensions. The syntax is almost similar to list comprehensions but the returned result is a generator instead of a list.\n\n::: {#08237cb7 .cell execution_count=7}\n``` {.python .cell-code}\ngen4 = nsquared(10)\nprint(gen4)\ngen5 = (i**2 for i in range(11))\nprint(gen5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<generator object nsquared at 0x7fef5cb41c00>\n<generator object <genexpr> at 0x7fefb94ff030>\n```\n:::\n:::\n\n\nBoth generators and generator expressions can be passed to the tuple, set or list constructors to create equivalent tuples, sets or lists.\n\n**NOTE** - I strongly recommend using finite generators in such use cases.\n\n::: {#89c15a9a .cell execution_count=8}\n``` {.python .cell-code}\n# note that the generator has to be reinitialized once it has been consumed\ngen4 = nsquared(10)\nprint(tuple(gen4))\ngen4 = nsquared(10)\nprint(list(gen4))\ngen4 = nsquared(10)\nprint(set(gen4))\n\nprint(tuple(i**2 for i in range(11)))\nprint(list(i**2 for i in range(11)))\nprint(set(i**2 for i in range(11)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(100, 81, 64, 49, 36, 25, 16, 9, 4, 1)\n[100, 81, 64, 49, 36, 25, 16, 9, 4, 1]\n{64, 1, 100, 36, 4, 9, 16, 81, 49, 25}\n(0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n{0, 1, 64, 4, 36, 100, 9, 16, 49, 81, 25}\n```\n:::\n:::\n\n\nAll the rules discussed in the previous sections about conditionals also apply to generator expressions\n\n::: {#fb32c857 .cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\nprint(list(i**2 for i in range(11) if i <=5))\nprint(list(i**2 if i <=5 else 1 for i in range(11)))\nmat = list(i**2 + j**2 if i < j else i + j for i in range(3) for j in range(3))\nprint(np.array(mat).reshape(3,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 4, 9, 16, 25]\n[0, 1, 4, 9, 16, 25, 1, 1, 1, 1, 1]\n[[0 1 4]\n [1 2 5]\n [2 3 4]]\n```\n:::\n:::\n\n\n### Advanced generator stuff\n\nSee PEP 380 for details. (https://www.python.org/dev/peps/pep-0380/)\n\nPython 3 introduced the concept of one generator delegating to sub-generators. This is achieved with the use of the `yield from` keyword. \n\nSuppose, you want to create a fancy new sequence by concatenating 3 sequences - the Fibonnaci sequence, a geometric series and a constant series. You can do this by creating a generator that delegates each of the subsequences to their own generators. To do this, we first create our subsequence generators.\n\n::: {#841b7f8b .cell execution_count=10}\n``` {.python .cell-code}\n# Same function, redefined here for clarity\ndef fib(n):\n    a, b = 0, 1\n    count = 0\n    while 1:\n        yield b\n        count += 1\n        if count == n:\n            return\n        a, b = b, a + b\n\ndef geom(n):\n    a = 1\n    count = 0\n    while True:\n        yield a\n        count += 1\n        if count == n:\n            return\n        a = a * 2\n\ndef constant(n):\n    count = 0\n    while True:\n        yield -1\n        count += 1\n        if count == n:\n            return\n```\n:::\n\n\nNow, we define our master generator.\n\n::: {#3772e34f .cell execution_count=11}\n``` {.python .cell-code}\ndef master_sequence(n):\n    g1 = fib(n)\n    g2 = geom(n)\n    g3 = constant(n)\n    count = 0\n    \n    yield from g1\n    yield from g2\n    yield from g3\n```\n:::\n\n\n::: {#38896313 .cell execution_count=12}\n``` {.python .cell-code}\nmaster_gen = master_sequence(5) # creates a sequence of length 15\nprint(list(master_gen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 1, 2, 3, 5, 1, 2, 4, 8, 16, -1, -1, -1, -1, -1]\n```\n:::\n:::\n\n\n#### A non-trivial example\n\nHere is a non-trivial example of generator used in the Keras API (https://keras.io/preprocessing/image/). The flow_from_directory method returns a generator that yields batches of image data indefinitely. This generator delegates the process to subgenerators that in turn yield data from subfolders created in your dataset. Using this generator, you can analyze very large image datasets on your PC without loading the entire dataset into your RAM. This data generator is used to feed neural nets during training using variations of gradient descent.\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /nfs/home/collinf/micromamba/envs/miashs-hpc/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n---\n",
    "supporting": [
      "4_Generators-sol_files"
    ],
    "filters": []
  }
}