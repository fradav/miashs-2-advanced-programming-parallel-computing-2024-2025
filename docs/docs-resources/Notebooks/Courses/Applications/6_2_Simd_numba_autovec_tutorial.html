<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="François-David Collin">
<meta name="author" content="Ghislain Durif">

<title>SIMD Autovectorization in Numba</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="6_2_Simd_numba_autovec_tutorial_files/libs/clipboard/clipboard.min.js"></script>
<script src="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/quarto.js"></script>
<script src="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/popper.min.js"></script>
<script src="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/anchor.min.js"></script>
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="6_2_Simd_numba_autovec_tutorial_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="6_2_Simd_numba_autovec_tutorial_files/libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="6_2_Simd_numba_autovec_tutorial.ipynb" download="6_2_Simd_numba_autovec_tutorial.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">SIMD Autovectorization in Numba</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliations</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">François-David Collin <a href="mailto:francois-david.collin@umontpellier.fr" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            CNRS
          </p>
        <p class="affiliation">
            IMAG
          </p>
        <p class="affiliation">
            Paul-Valéry Montpellier 3 University
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Ghislain Durif <a href="mailto:ghislain.durif@ens-lyon.fr" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            CNRS
          </p>
        <p class="affiliation">
            LBMC
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="simd-autovectorization-in-numba" class="level1">
<h1>SIMD Autovectorization in Numba</h1>
<p>Most modern CPUs have support for instructions that apply the same operation to multiple data elements simultaneously. These are called “Single Instruction, Multiple Data” (SIMD) operations, and the LLVM backend used by Numba can generate them in some cases to execute loops more quickly. (This process is called “autovectorization.”)</p>
<p>For example, Intel processors have support for SIMD instruction sets like:</p>
<ul>
<li>SSE (128-bit inputs)</li>
<li>AVX (256-bit inputs)</li>
<li>AVX-512 (512-bit inputs, Skylake-X and later or Xeon Phi)</li>
</ul>
<p>These wide instructions typically operate on as many values as will fit into an input register. For AVX instructions, this means that either 8 float32 values or 4 float64 values can be processed as a single input. As a result, the NumPy dtype that you use can potentially impact performance to a greater degree than when SIMD is not in use.</p>
<div id="06da5b1e" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="1">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>It can be somewhat tricky to determine when LLVM has successfully autovectorized a loop. The Numba team is working on exporting diagnostic information to show where the autovectorizer has generated SIMD code. For now, we can use a fairly crude approach of searching the assembly language generated by LLVM for SIMD instructions.</p>
<p>It is also interesting to note what kind of SIMD is used on your system. On x86_64, the name of the registers used indicates which level of SIMD is in use:</p>
<ul>
<li>SSE: <code>xmmX</code></li>
<li>AVX/AVX2: <code>ymmX</code></li>
<li>AVX-512: <code>zmmX</code></li>
</ul>
<p>where X is an integer.</p>
<p><strong>Note</strong>: The method we use below to find SIMD instructions will only work on Intel/AMD CPUs. Other platforms have entirely different assembly language syntax for SIMD instructions.</p>
<div id="b7b3490a" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_instr(func, keyword, sig<span class="op">=</span><span class="dv">0</span>, limit<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> func.inspect_asm(func.signatures[sig]).split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> keyword <span class="kw">in</span> l:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(l)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> count <span class="op">&gt;=</span> limit:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'No instructions found'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="basic-simd" class="level2">
<h2 class="anchored" data-anchor-id="basic-simd">Basic SIMD</h2>
<p>Let’s start with a simple function that returns the square difference between two arrays, as you might write for a least-squares optimization:</p>
<div id="6825b03e" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;-&quot;}" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sqdiff(x, y):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> (x[i] <span class="op">-</span> y[i])<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="43ea7bae" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x32 <span class="op">=</span> np.linspace(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10000</span>, dtype<span class="op">=</span>np.float32)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>y32 <span class="op">=</span> np.linspace(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">10000</span>, dtype<span class="op">=</span>np.float32)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sqdiff(x32, y32)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="365f4b3e" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="5">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x64 <span class="op">=</span> x32.astype(np.float64)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>y64 <span class="op">=</span> y32.astype(np.float64)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>sqdiff(x64, y64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Numba has created two different implementations of the function, one for <code>float32</code> 1-D arrays, and one for <code>float64</code> 1-D arrays:</p>
<div id="989c1079" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="6">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>sqdiff.signatures</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This allows Numba (and LLVM) to specialize the use of the SIMD instructions for each situation. In particular, using lower precision floating point allows twice as many values to fit into a SIMD register. We will see that for the same number of elements, the <code>float32</code> calculation goes twice as fast:</p>
<div id="3a9be178" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="7">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit sqdiff(x32, y32)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit sqdiff(x64, y64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can check for SIMD instructions in both cases. (Due to the order of compilation above, signature 0 is the <code>float32</code> implementation and signature 1 is the <code>float64</code> implementation.)</p>
<div id="299aeaa9" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="8">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'float32:'</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>find_instr(sqdiff, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---</span><span class="ch">\n</span><span class="st">float64:'</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>find_instr(sqdiff, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In x86_64 assembly, SSE uses <code>subps</code> for “subtraction packed single precision” (AVX uses <code>vsubps</code>), representing vector float32 operations. The <code>subpd</code> instruction (AVX = <code>vsubpd</code>) stands for “subtraction packed double precision”, representing float64 operations.</p>
</section>
<section id="simd-and-division" class="level2">
<h2 class="anchored" data-anchor-id="simd-and-division">SIMD and Division</h2>
<p>In general, the autovectorizer cannot deal with branches inside loops, although this is an area where LLVM is likely to improve in the future. Your best bet for SIMD acceleration is to only have pure math operations in the loop.</p>
<p>As a result, you would naturally assume a function like this would be OK:</p>
<div id="cb6c47f5" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="9">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff1(x, y):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fe8462c1" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="10">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>frac_diff1(x32, y32)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="dbdcef34" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="11">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>find_instr(frac_diff1, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>No instructions found</code>?!</p>
<p>The problem is that division by zero can behave in two different ways:</p>
<ul>
<li>In Python, division by zero raises an exception.</li>
<li>In NumPy, division by zero results in a <code>NaN</code>, like in C.</li>
</ul>
<p>By default, Numba <code>@jit</code> follows the Python convention, and <code>@vectorize</code>/<code>@guvectorize</code> follow the NumPy convention. When following the Python convention, a simple division operation <code>r = x / y</code> expands out into something like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ZeroDivisionError</span>()</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> x <span class="op">/</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This branching code causes the autovectorizer to give up, and no SIMD to be generated for our example above.</p>
<p>Fortunately, Numba allows you to override the “error model” of the function if you don’t want a <code>ZeroDivisionError</code> to be raised:</p>
<div id="789a637b" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="12">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff2(x, y):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="49d90eba" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="13">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>frac_diff2(x32, y32)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e823fcc5" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="14">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>find_instr(frac_diff2, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We have SIMD instructions again, but when we check the speed:</p>
<div id="a9f3055c" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="15">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff2(x32, y32)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff2(x64, y64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This is faster than the no-SIMD case, but there doesn’t seem to be a speed benefit with <code>float32</code> inputs. What’s going on?</p>
<p>The remaining issue is very subtle. We can see it if we look at a type-annotated version of the function:</p>
<div id="6da97bd1" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="16">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>frac_diff2.inspect_types(pretty<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If you expand out line 5 in the float32 version of the function, you will see the following bit of Numba IR:</p>
<pre><code>$const28.2 = const(float, 2.0) :: float64
$28.5 = getitem(value=x, index=i) :: float32
$28.8 = getitem(value=y, index=i) :: float32
$28.9 = $28.5 - $28.8 :: float32
del $28.8
del $28.5
$28.10 = $const28.2 * $28.9 :: float64</code></pre>
<p>Notice that the constant <code>2</code> has been typed as a float64 value. Later, this causes the multiplication <code>2 * (x[i] - y[i]</code> to promote up to float64, and then the rest of the calculation becomes float64. This is a situation where Numba is being overly conservative (and should be fixed at some point), but we can tweak this behavior by casting the constant to the type we want:</p>
<div id="4c6ee5ce" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="17">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff3(x, y):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> x.dtype <span class="co"># Cast the constant using the dtype of the input</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Could also use np.float32(2) to always use same type, regardless of input</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> dt.<span class="bu">type</span>(<span class="dv">2</span>) <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="330b8374" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="18">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>frac_diff3(x32, y32)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a41bd836" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="19">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff3(x32, y32)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff3(x64, y64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now our float32 version is nice and speedy (and 6x faster than what we started with, if we only care about float32).</p>
</section>
<section id="simd-and-reductions" class="level2">
<h2 class="anchored" data-anchor-id="simd-and-reductions">SIMD and Reductions</h2>
<p>The autovectorizer can also optimize reduction loops, but only with permission. Normally, compilers are very careful not to reorder floating point instructions because floating point arithmetic is approximate, so mathematically allowed transformations do not always give the same result. For example, it is not generally true for floating point numbers that:</p>
<pre><code>(a + (b + c)) == ((a + b) + c)</code></pre>
<p>For many situations, the round-off error that causes the difference between the left and the right is not important, so changing the order of additions is acceptable for a performance increase.</p>
<p>To allow reordering of operations, we need to tell Numba to enable <code>fastmath</code> optimizations:</p>
<div id="83923d3c" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="20">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_sum(A):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># without fastmath, this loop must accumulate in strict order</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> A:</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, fastmath<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_sum_fast(A):</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with fastmath, the reduction can be vectorized as floating point</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># reassociation is permitted.</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> A:</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0539a907" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="21">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>do_sum(x32)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>find_instr(do_sum, keyword<span class="op">=</span><span class="st">'mulp'</span>)  <span class="co"># look for vector multiplication</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="77af64f9" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="22">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>do_sum_fast(x32)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>find_instr(do_sum_fast, keyword<span class="op">=</span><span class="st">'mulp'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The fast version is 4x faster:</p>
<div id="65116d98" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="23">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit do_sum(x32)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit do_sum_fast(x32)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="simd-and-special-functions" class="level2">
<h2 class="anchored" data-anchor-id="simd-and-special-functions">SIMD and Special Functions</h2>
<p>If you follow the above guidelines, SIMD autovectorization will work for all basic math operations (<code>+</code>,<code>-</code>,<code>*</code>,<code>\</code>), but generally will not work for function calls in the loop, unless LLVM can inline the function and there is only basic math in the function body.</p>
<p>However, we build Numba (if you get conda packages from Anaconda or wheels from PyPI) using a patched version of LLVM that supports vectorization of special math functions when Intel SVML (“Short Vector Math Library”) is present. This library comes with the Intel compiler, and is also freely redistributable. We’ve installed it in the current conda environment using <code>conda install -c numba icc_rt</code>, as we can verify here:</p>
<div id="86d36a1c" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="24">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> conda <span class="bu">list</span> icc_rt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Thanks to this library, we can still get SIMD vectorization in a function like this:</p>
<div id="57f67498" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;-&quot;}" data-execution_count="25">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>SQRT_2PI <span class="op">=</span> np.sqrt(<span class="dv">2</span> <span class="op">*</span> np.pi)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>, fastmath<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kde(x, means, widths):</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Compute value of gaussian kernel density estimate.</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co">    x - location of evaluation</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co">    means - array of kernel means</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co">    widths - array of kernel widths</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> means.shape[<span class="dv">0</span>]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> np.exp( <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> ((x <span class="op">-</span> means[i]) <span class="op">/</span> widths[i])<span class="op">**</span><span class="dv">2</span> ) <span class="op">/</span> widths[i]</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc <span class="op">/</span> SQRT_2PI <span class="op">/</span> n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0a33dd60" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="26">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The distribution we are approximating is flat between -1 and 1, so we expect a KDE value of ~0.5 everywhere</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>means <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, size<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># These widths are not selected in any reasonable way.  Consult your local statistician before approximating a PDF.</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>widths <span class="op">=</span> np.random.uniform(<span class="fl">0.1</span>, <span class="fl">0.3</span>, size<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can see that SIMD instructions were generated:</p>
<div id="e2969537" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="27">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>find_instr(kde, <span class="st">'subp'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can also see that calls to the special Intel SVML functions for <code>exp</code> were generated:</p>
<div id="32774b12" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="28">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>find_instr(kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7b3ba1ba" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="29">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If we recompile the function (which is possible since the <code>.py_func</code> attribute holds the original Python function) with the extra flags to allow division and reductions to work, this stops all autovectorization of the loop:</p>
<div id="b9d3c700" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="30">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>slow_kde <span class="op">=</span> jit(nopython<span class="op">=</span><span class="va">True</span>)(kde.py_func)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>slow_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Note that we get a slightly different answer, both due to the different order of operations, and the small differences in SVML <code>exp</code> compared to the default <code>exp</code>. We also see that there is no SIMD or calls to SVML:</p>
<div id="652aecd8" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="31">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>find_instr(slow_kde, keyword<span class="op">=</span><span class="st">'subp'</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---'</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>find_instr(slow_kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And the function is much slower than the original:</p>
<div id="26c07c52" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="32">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit slow_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And only the SIMD vectorized version is faster than doing this in pure NumPy:</p>
<div id="8917ff37" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="33">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numpy_kde(x, means, widths):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> (np.exp( <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> ((x <span class="op">-</span> means) <span class="op">/</span> widths)<span class="op">**</span><span class="dv">2</span> ) <span class="op">/</span> widths).mean()</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># .mean() already divides by n</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc <span class="op">/</span> SQRT_2PI</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d1532c2e" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="34">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>numpy_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0a570eed" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="35">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Why is NumPy as fast as it is? In this case, it is because the Anaconda build of NumPy uses MKL to accelerate (with SIMD and threads) many of the individial ufuncs, so it is only when Numba can combine all the operations together that the speed boost emerges.</p>
<p>Incidentally, although we wrote out the iteration for <code>kde</code> as a for loop to highlight what was going on, you still get the benefit of SIMD in Numba when compiling array expressions. We could have compiled <code>numpy_kde</code> directly:</p>
<div id="afab4ccb" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="36">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>numba_numpy_kde <span class="op">=</span> jit(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>, fastmath<span class="op">=</span><span class="va">True</span>)(numpy_kde)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>numba_numpy_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="64f8ef8c" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;subslide&quot;}" data-execution_count="37">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>find_instr(numba_numpy_kde, keyword<span class="op">=</span><span class="st">'subp'</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---'</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>find_instr(numba_numpy_kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And it is nearly as fast as our manual looping version, and 2x faster than NumPy alone:</p>
<div id="393a6548" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="38">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numba_numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_kde(<span class="fl">0.4</span>, means, widths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<!-- -->

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb42" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> SIMD Autovectorization in Numba</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>Most modern CPUs have support for instructions that apply the same operation to multiple data elements simultaneously.  These are called "Single Instruction, Multiple Data" (SIMD) operations, and the LLVM backend used by Numba can generate them in some cases to execute loops more quickly.  (This process is called "autovectorization.")</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>For example, Intel processors have support for SIMD instruction sets like:</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>SSE (128-bit inputs)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>AVX (256-bit inputs)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>AVX-512 (512-bit inputs, Skylake-X and later or Xeon Phi)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>These wide instructions typically operate on as many values as will fit into an input register.  For AVX instructions, this means that either 8 float32 values or 4 float64 values can be processed as a single input.  As a result, the NumPy dtype that you use can potentially impact performance to a greater degree than when SIMD is not in use.</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> jit</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>It can be somewhat tricky to determine when LLVM has successfully autovectorized a loop.  The Numba team is working on exporting diagnostic information to show where the autovectorizer has generated SIMD code.  For now, we can use a fairly crude approach of searching the assembly language generated by LLVM for SIMD instructions.</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>It is also interesting to note what kind of SIMD is used on your system.  On x86_64, the name of the registers used indicates which level of SIMD is in use:</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>SSE: <span class="in">`xmmX`</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>AVX/AVX2: <span class="in">`ymmX`</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>AVX-512: <span class="in">`zmmX`</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>where X is an integer.</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>**Note**: The method we use below to find SIMD instructions will only work on Intel/AMD CPUs.  Other platforms have entirely different assembly language syntax for SIMD instructions.</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_instr(func, keyword, sig<span class="op">=</span><span class="dv">0</span>, limit<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> func.inspect_asm(func.signatures[sig]).split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> keyword <span class="kw">in</span> l:</span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(l)</span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> count <span class="op">&gt;=</span> limit:</span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'No instructions found'</span>)</span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a><span class="fu">## Basic SIMD</span></span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>Let's start with a simple function that returns the square difference between two arrays, as you might write for a least-squares optimization:</span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: '-'}</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sqdiff(x, y):</span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> (x[i] <span class="op">-</span> y[i])<span class="op">**</span><span class="dv">2</span></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>x32 <span class="op">=</span> np.linspace(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10000</span>, dtype<span class="op">=</span>np.float32)</span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>y32 <span class="op">=</span> np.linspace(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">10000</span>, dtype<span class="op">=</span>np.float32)</span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>sqdiff(x32, y32)</span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a>x64 <span class="op">=</span> x32.astype(np.float64)</span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a>y64 <span class="op">=</span> y32.astype(np.float64)</span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>sqdiff(x64, y64)</span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a>Numba has created two different implementations of the function, one for <span class="in">`float32`</span> 1-D arrays, and one for <span class="in">`float64`</span> 1-D arrays:</span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a>sqdiff.signatures</span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a>This allows Numba (and LLVM) to specialize the use of the SIMD instructions for each situation.  In particular, using lower precision floating point allows twice as many values to fit into a SIMD register.  We will see that for the same number of elements, the <span class="in">`float32`</span> calculation goes twice as fast:</span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit sqdiff(x32, y32)</span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit sqdiff(x64, y64)</span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>We can check for SIMD instructions in both cases.  (Due to the order of compilation above, signature 0 is the <span class="in">`float32`</span> implementation and signature 1 is the <span class="in">`float64`</span> implementation.)</span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'float32:'</span>)</span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a>find_instr(sqdiff, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---</span><span class="ch">\n</span><span class="st">float64:'</span>)</span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a>find_instr(sqdiff, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a>In x86_64 assembly, SSE uses <span class="in">`subps`</span> for "subtraction packed single precision" (AVX uses <span class="in">`vsubps`</span>), representing vector float32 operations.  The <span class="in">`subpd`</span> instruction (AVX = <span class="in">`vsubpd`</span>) stands for "subtraction packed double precision", representing float64 operations.</span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a><span class="fu">## SIMD and Division</span></span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a>In general, the autovectorizer cannot deal with branches inside loops, although this is an area where LLVM is likely to improve in the future.  Your best bet for SIMD acceleration is to only have pure math operations in the loop.</span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a>As a result, you would naturally assume a function like this would be OK:</span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff1(x, y):</span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-137"><a href="#cb42-137" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-138"><a href="#cb42-138" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-139"><a href="#cb42-139" aria-hidden="true" tabindex="-1"></a>frac_diff1(x32, y32)</span>
<span id="cb42-140"><a href="#cb42-140" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-141"><a href="#cb42-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-144"><a href="#cb42-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-145"><a href="#cb42-145" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-146"><a href="#cb42-146" aria-hidden="true" tabindex="-1"></a>find_instr(frac_diff1, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-147"><a href="#cb42-147" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-148"><a href="#cb42-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-149"><a href="#cb42-149" aria-hidden="true" tabindex="-1"></a><span class="in">`No instructions found`</span>?!</span>
<span id="cb42-150"><a href="#cb42-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-151"><a href="#cb42-151" aria-hidden="true" tabindex="-1"></a>The problem is that division by zero can behave in two different ways:</span>
<span id="cb42-152"><a href="#cb42-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-153"><a href="#cb42-153" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>In Python, division by zero raises an exception.</span>
<span id="cb42-154"><a href="#cb42-154" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>In NumPy, division by zero results in a <span class="in">`NaN`</span>, like in C.</span>
<span id="cb42-155"><a href="#cb42-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-156"><a href="#cb42-156" aria-hidden="true" tabindex="-1"></a>By default, Numba <span class="in">`@jit`</span> follows the Python convention, and <span class="in">`@vectorize`</span>/<span class="in">`@guvectorize`</span> follow the NumPy convention.  When following the Python convention, a simple division operation <span class="in">`r = x / y`</span> expands out into something like:</span>
<span id="cb42-157"><a href="#cb42-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-158"><a href="#cb42-158" aria-hidden="true" tabindex="-1"></a><span class="in">``` python</span></span>
<span id="cb42-159"><a href="#cb42-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-160"><a href="#cb42-160" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb42-161"><a href="#cb42-161" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ZeroDivisionError</span>()</span>
<span id="cb42-162"><a href="#cb42-162" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb42-163"><a href="#cb42-163" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> x <span class="op">/</span> y</span>
<span id="cb42-164"><a href="#cb42-164" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-165"><a href="#cb42-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-166"><a href="#cb42-166" aria-hidden="true" tabindex="-1"></a>This branching code causes the autovectorizer to give up, and no SIMD to be generated for our example above.</span>
<span id="cb42-167"><a href="#cb42-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-168"><a href="#cb42-168" aria-hidden="true" tabindex="-1"></a>Fortunately, Numba allows you to override the "error model" of the function if you don't want a <span class="in">`ZeroDivisionError`</span> to be raised:</span>
<span id="cb42-169"><a href="#cb42-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-172"><a href="#cb42-172" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-173"><a href="#cb42-173" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-174"><a href="#cb42-174" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>)</span>
<span id="cb42-175"><a href="#cb42-175" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff2(x, y):</span>
<span id="cb42-176"><a href="#cb42-176" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb42-177"><a href="#cb42-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb42-178"><a href="#cb42-178" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb42-179"><a href="#cb42-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb42-180"><a href="#cb42-180" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-181"><a href="#cb42-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-184"><a href="#cb42-184" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-185"><a href="#cb42-185" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-186"><a href="#cb42-186" aria-hidden="true" tabindex="-1"></a>frac_diff2(x32, y32)</span>
<span id="cb42-187"><a href="#cb42-187" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-188"><a href="#cb42-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-191"><a href="#cb42-191" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-192"><a href="#cb42-192" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-193"><a href="#cb42-193" aria-hidden="true" tabindex="-1"></a>find_instr(frac_diff2, keyword<span class="op">=</span><span class="st">'subp'</span>, sig<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-194"><a href="#cb42-194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-195"><a href="#cb42-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-196"><a href="#cb42-196" aria-hidden="true" tabindex="-1"></a>We have SIMD instructions again, but when we check the speed:</span>
<span id="cb42-197"><a href="#cb42-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-200"><a href="#cb42-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-201"><a href="#cb42-201" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-202"><a href="#cb42-202" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff2(x32, y32)</span>
<span id="cb42-203"><a href="#cb42-203" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff2(x64, y64)</span>
<span id="cb42-204"><a href="#cb42-204" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-205"><a href="#cb42-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-206"><a href="#cb42-206" aria-hidden="true" tabindex="-1"></a>This is faster than the no-SIMD case, but there doesn't seem to be a speed benefit with <span class="in">`float32`</span> inputs.  What's going on?</span>
<span id="cb42-207"><a href="#cb42-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-208"><a href="#cb42-208" aria-hidden="true" tabindex="-1"></a>The remaining issue is very subtle.  We can see it if we look at a type-annotated version of the function:</span>
<span id="cb42-209"><a href="#cb42-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-212"><a href="#cb42-212" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-213"><a href="#cb42-213" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-214"><a href="#cb42-214" aria-hidden="true" tabindex="-1"></a>frac_diff2.inspect_types(pretty<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-215"><a href="#cb42-215" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-216"><a href="#cb42-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-217"><a href="#cb42-217" aria-hidden="true" tabindex="-1"></a>If you expand out line 5 in the float32 version of the function, you will see the following bit of Numba IR:</span>
<span id="cb42-218"><a href="#cb42-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-219"><a href="#cb42-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-220"><a href="#cb42-220" aria-hidden="true" tabindex="-1"></a><span class="in">$const28.2 = const(float, 2.0) :: float64</span></span>
<span id="cb42-221"><a href="#cb42-221" aria-hidden="true" tabindex="-1"></a><span class="in">$28.5 = getitem(value=x, index=i) :: float32</span></span>
<span id="cb42-222"><a href="#cb42-222" aria-hidden="true" tabindex="-1"></a><span class="in">$28.8 = getitem(value=y, index=i) :: float32</span></span>
<span id="cb42-223"><a href="#cb42-223" aria-hidden="true" tabindex="-1"></a><span class="in">$28.9 = $28.5 - $28.8 :: float32</span></span>
<span id="cb42-224"><a href="#cb42-224" aria-hidden="true" tabindex="-1"></a><span class="in">del $28.8</span></span>
<span id="cb42-225"><a href="#cb42-225" aria-hidden="true" tabindex="-1"></a><span class="in">del $28.5</span></span>
<span id="cb42-226"><a href="#cb42-226" aria-hidden="true" tabindex="-1"></a><span class="in">$28.10 = $const28.2 * $28.9 :: float64</span></span>
<span id="cb42-227"><a href="#cb42-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-228"><a href="#cb42-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-229"><a href="#cb42-229" aria-hidden="true" tabindex="-1"></a>Notice that the constant <span class="in">`2`</span> has been typed as a float64 value.  Later, this causes the multiplication <span class="in">`2 * (x[i] - y[i]`</span> to promote up to float64, and then the rest of the calculation becomes float64.  This is a situation where Numba is being overly conservative (and should be fixed at some point), but we can tweak this behavior by casting the constant to the type we want:</span>
<span id="cb42-230"><a href="#cb42-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-233"><a href="#cb42-233" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-234"><a href="#cb42-234" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-235"><a href="#cb42-235" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>)</span>
<span id="cb42-236"><a href="#cb42-236" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> frac_diff3(x, y):</span>
<span id="cb42-237"><a href="#cb42-237" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty_like(x)</span>
<span id="cb42-238"><a href="#cb42-238" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> x.dtype <span class="co"># Cast the constant using the dtype of the input</span></span>
<span id="cb42-239"><a href="#cb42-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):</span>
<span id="cb42-240"><a href="#cb42-240" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Could also use np.float32(2) to always use same type, regardless of input</span></span>
<span id="cb42-241"><a href="#cb42-241" aria-hidden="true" tabindex="-1"></a>        out[i] <span class="op">=</span> dt.<span class="bu">type</span>(<span class="dv">2</span>) <span class="op">*</span> (x[i] <span class="op">-</span> y[i]) <span class="op">/</span> (x[i] <span class="op">+</span> y[i])</span>
<span id="cb42-242"><a href="#cb42-242" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb42-243"><a href="#cb42-243" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-244"><a href="#cb42-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-247"><a href="#cb42-247" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-248"><a href="#cb42-248" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-249"><a href="#cb42-249" aria-hidden="true" tabindex="-1"></a>frac_diff3(x32, y32)</span>
<span id="cb42-250"><a href="#cb42-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-251"><a href="#cb42-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-254"><a href="#cb42-254" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-255"><a href="#cb42-255" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-256"><a href="#cb42-256" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff3(x32, y32)</span>
<span id="cb42-257"><a href="#cb42-257" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit frac_diff3(x64, y64)</span>
<span id="cb42-258"><a href="#cb42-258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-259"><a href="#cb42-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-260"><a href="#cb42-260" aria-hidden="true" tabindex="-1"></a>Now our float32 version is nice and speedy (and 6x faster than what we started with, if we only care about float32).</span>
<span id="cb42-261"><a href="#cb42-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-262"><a href="#cb42-262" aria-hidden="true" tabindex="-1"></a><span class="fu">## SIMD and Reductions</span></span>
<span id="cb42-263"><a href="#cb42-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-264"><a href="#cb42-264" aria-hidden="true" tabindex="-1"></a>The autovectorizer can also optimize reduction loops, but only with permission.  Normally, compilers are very careful not to reorder floating point instructions because floating point arithmetic is approximate, so mathematically allowed transformations do not always give the same result.  For example, it is not generally true for floating point numbers that:</span>
<span id="cb42-265"><a href="#cb42-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-266"><a href="#cb42-266" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-267"><a href="#cb42-267" aria-hidden="true" tabindex="-1"></a><span class="in">(a + (b + c)) == ((a + b) + c)</span></span>
<span id="cb42-268"><a href="#cb42-268" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-269"><a href="#cb42-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-270"><a href="#cb42-270" aria-hidden="true" tabindex="-1"></a>For many situations, the round-off error that causes the difference between the left and the right is not important, so changing the order of additions is acceptable for a performance increase.</span>
<span id="cb42-271"><a href="#cb42-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-272"><a href="#cb42-272" aria-hidden="true" tabindex="-1"></a>To allow reordering of operations, we need to tell Numba to enable <span class="in">`fastmath`</span> optimizations:</span>
<span id="cb42-273"><a href="#cb42-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-276"><a href="#cb42-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-277"><a href="#cb42-277" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-278"><a href="#cb42-278" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-279"><a href="#cb42-279" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_sum(A):</span>
<span id="cb42-280"><a href="#cb42-280" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb42-281"><a href="#cb42-281" aria-hidden="true" tabindex="-1"></a>    <span class="co"># without fastmath, this loop must accumulate in strict order</span></span>
<span id="cb42-282"><a href="#cb42-282" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> A:</span>
<span id="cb42-283"><a href="#cb42-283" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb42-284"><a href="#cb42-284" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc</span>
<span id="cb42-285"><a href="#cb42-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-286"><a href="#cb42-286" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, fastmath<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-287"><a href="#cb42-287" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_sum_fast(A):</span>
<span id="cb42-288"><a href="#cb42-288" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb42-289"><a href="#cb42-289" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with fastmath, the reduction can be vectorized as floating point</span></span>
<span id="cb42-290"><a href="#cb42-290" aria-hidden="true" tabindex="-1"></a>    <span class="co"># reassociation is permitted.</span></span>
<span id="cb42-291"><a href="#cb42-291" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> A:</span>
<span id="cb42-292"><a href="#cb42-292" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb42-293"><a href="#cb42-293" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc</span>
<span id="cb42-294"><a href="#cb42-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-295"><a href="#cb42-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-298"><a href="#cb42-298" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-299"><a href="#cb42-299" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-300"><a href="#cb42-300" aria-hidden="true" tabindex="-1"></a>do_sum(x32)</span>
<span id="cb42-301"><a href="#cb42-301" aria-hidden="true" tabindex="-1"></a>find_instr(do_sum, keyword<span class="op">=</span><span class="st">'mulp'</span>)  <span class="co"># look for vector multiplication</span></span>
<span id="cb42-302"><a href="#cb42-302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-303"><a href="#cb42-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-306"><a href="#cb42-306" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-307"><a href="#cb42-307" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-308"><a href="#cb42-308" aria-hidden="true" tabindex="-1"></a>do_sum_fast(x32)</span>
<span id="cb42-309"><a href="#cb42-309" aria-hidden="true" tabindex="-1"></a>find_instr(do_sum_fast, keyword<span class="op">=</span><span class="st">'mulp'</span>)</span>
<span id="cb42-310"><a href="#cb42-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-311"><a href="#cb42-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-312"><a href="#cb42-312" aria-hidden="true" tabindex="-1"></a>The fast version is 4x faster:</span>
<span id="cb42-313"><a href="#cb42-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-316"><a href="#cb42-316" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-317"><a href="#cb42-317" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-318"><a href="#cb42-318" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit do_sum(x32)</span>
<span id="cb42-319"><a href="#cb42-319" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit do_sum_fast(x32)</span>
<span id="cb42-320"><a href="#cb42-320" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-321"><a href="#cb42-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-322"><a href="#cb42-322" aria-hidden="true" tabindex="-1"></a><span class="fu">## SIMD and Special Functions</span></span>
<span id="cb42-323"><a href="#cb42-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-324"><a href="#cb42-324" aria-hidden="true" tabindex="-1"></a>If you follow the above guidelines, SIMD autovectorization will work for all basic math operations (<span class="in">`+`</span>,<span class="in">`-`</span>,<span class="in">`*`</span>,<span class="in">`\`</span>), but generally will not work for function calls in the loop, unless LLVM can inline the function and there is only basic math in the function body.</span>
<span id="cb42-325"><a href="#cb42-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-326"><a href="#cb42-326" aria-hidden="true" tabindex="-1"></a>However, we build Numba (if you get conda packages from Anaconda or wheels from PyPI) using a patched version of LLVM that supports vectorization of special math functions when Intel SVML ("Short Vector Math Library") is present.  This library comes with the Intel compiler, and is also freely redistributable.  We've installed it in the current conda environment using <span class="in">`conda install -c numba icc_rt`</span>, as we can verify here:</span>
<span id="cb42-327"><a href="#cb42-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-330"><a href="#cb42-330" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-331"><a href="#cb42-331" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-332"><a href="#cb42-332" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> conda <span class="bu">list</span> icc_rt</span>
<span id="cb42-333"><a href="#cb42-333" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-334"><a href="#cb42-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-335"><a href="#cb42-335" aria-hidden="true" tabindex="-1"></a>Thanks to this library, we can still get SIMD vectorization in a function like this:</span>
<span id="cb42-336"><a href="#cb42-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-339"><a href="#cb42-339" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-340"><a href="#cb42-340" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: '-'}</span></span>
<span id="cb42-341"><a href="#cb42-341" aria-hidden="true" tabindex="-1"></a>SQRT_2PI <span class="op">=</span> np.sqrt(<span class="dv">2</span> <span class="op">*</span> np.pi)</span>
<span id="cb42-342"><a href="#cb42-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-343"><a href="#cb42-343" aria-hidden="true" tabindex="-1"></a><span class="at">@jit</span>(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>, fastmath<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-344"><a href="#cb42-344" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kde(x, means, widths):</span>
<span id="cb42-345"><a href="#cb42-345" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Compute value of gaussian kernel density estimate.</span></span>
<span id="cb42-346"><a href="#cb42-346" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb42-347"><a href="#cb42-347" aria-hidden="true" tabindex="-1"></a><span class="co">    x - location of evaluation</span></span>
<span id="cb42-348"><a href="#cb42-348" aria-hidden="true" tabindex="-1"></a><span class="co">    means - array of kernel means</span></span>
<span id="cb42-349"><a href="#cb42-349" aria-hidden="true" tabindex="-1"></a><span class="co">    widths - array of kernel widths</span></span>
<span id="cb42-350"><a href="#cb42-350" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb42-351"><a href="#cb42-351" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> means.shape[<span class="dv">0</span>]</span>
<span id="cb42-352"><a href="#cb42-352" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb42-353"><a href="#cb42-353" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb42-354"><a href="#cb42-354" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">+=</span> np.exp( <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> ((x <span class="op">-</span> means[i]) <span class="op">/</span> widths[i])<span class="op">**</span><span class="dv">2</span> ) <span class="op">/</span> widths[i]</span>
<span id="cb42-355"><a href="#cb42-355" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc <span class="op">/</span> SQRT_2PI <span class="op">/</span> n</span>
<span id="cb42-356"><a href="#cb42-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-357"><a href="#cb42-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-360"><a href="#cb42-360" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-361"><a href="#cb42-361" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-362"><a href="#cb42-362" aria-hidden="true" tabindex="-1"></a><span class="co"># The distribution we are approximating is flat between -1 and 1, so we expect a KDE value of ~0.5 everywhere</span></span>
<span id="cb42-363"><a href="#cb42-363" aria-hidden="true" tabindex="-1"></a>means <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, size<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb42-364"><a href="#cb42-364" aria-hidden="true" tabindex="-1"></a><span class="co"># These widths are not selected in any reasonable way.  Consult your local statistician before approximating a PDF.</span></span>
<span id="cb42-365"><a href="#cb42-365" aria-hidden="true" tabindex="-1"></a>widths <span class="op">=</span> np.random.uniform(<span class="fl">0.1</span>, <span class="fl">0.3</span>, size<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb42-366"><a href="#cb42-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-367"><a href="#cb42-367" aria-hidden="true" tabindex="-1"></a>kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-368"><a href="#cb42-368" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-369"><a href="#cb42-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-370"><a href="#cb42-370" aria-hidden="true" tabindex="-1"></a>We can see that SIMD instructions were generated:</span>
<span id="cb42-371"><a href="#cb42-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-374"><a href="#cb42-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-375"><a href="#cb42-375" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-376"><a href="#cb42-376" aria-hidden="true" tabindex="-1"></a>find_instr(kde, <span class="st">'subp'</span>)</span>
<span id="cb42-377"><a href="#cb42-377" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-378"><a href="#cb42-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-379"><a href="#cb42-379" aria-hidden="true" tabindex="-1"></a>We can also see that calls to the special Intel SVML functions for <span class="in">`exp`</span> were generated:</span>
<span id="cb42-380"><a href="#cb42-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-383"><a href="#cb42-383" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-384"><a href="#cb42-384" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-385"><a href="#cb42-385" aria-hidden="true" tabindex="-1"></a>find_instr(kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span>
<span id="cb42-386"><a href="#cb42-386" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-387"><a href="#cb42-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-390"><a href="#cb42-390" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-391"><a href="#cb42-391" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-392"><a href="#cb42-392" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-393"><a href="#cb42-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-394"><a href="#cb42-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-395"><a href="#cb42-395" aria-hidden="true" tabindex="-1"></a>If we recompile the function (which is possible since the <span class="in">`.py_func`</span> attribute holds the original Python function) with the extra flags to allow division and reductions to work, this stops all autovectorization of the loop:</span>
<span id="cb42-396"><a href="#cb42-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-399"><a href="#cb42-399" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-400"><a href="#cb42-400" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-401"><a href="#cb42-401" aria-hidden="true" tabindex="-1"></a>slow_kde <span class="op">=</span> jit(nopython<span class="op">=</span><span class="va">True</span>)(kde.py_func)</span>
<span id="cb42-402"><a href="#cb42-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-403"><a href="#cb42-403" aria-hidden="true" tabindex="-1"></a>slow_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-404"><a href="#cb42-404" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-405"><a href="#cb42-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-406"><a href="#cb42-406" aria-hidden="true" tabindex="-1"></a>Note that we get a slightly different answer, both due to the different order of operations, and the small differences in SVML <span class="in">`exp`</span> compared to the default <span class="in">`exp`</span>.  We also see that there is no SIMD or calls to SVML:</span>
<span id="cb42-407"><a href="#cb42-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-410"><a href="#cb42-410" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-411"><a href="#cb42-411" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-412"><a href="#cb42-412" aria-hidden="true" tabindex="-1"></a>find_instr(slow_kde, keyword<span class="op">=</span><span class="st">'subp'</span>)</span>
<span id="cb42-413"><a href="#cb42-413" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---'</span>)</span>
<span id="cb42-414"><a href="#cb42-414" aria-hidden="true" tabindex="-1"></a>find_instr(slow_kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span>
<span id="cb42-415"><a href="#cb42-415" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-416"><a href="#cb42-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-417"><a href="#cb42-417" aria-hidden="true" tabindex="-1"></a>And the function is much slower than the original:</span>
<span id="cb42-418"><a href="#cb42-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-421"><a href="#cb42-421" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-422"><a href="#cb42-422" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-423"><a href="#cb42-423" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-424"><a href="#cb42-424" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit slow_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-425"><a href="#cb42-425" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-426"><a href="#cb42-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-427"><a href="#cb42-427" aria-hidden="true" tabindex="-1"></a>And only the SIMD vectorized version is faster than doing this in pure NumPy:</span>
<span id="cb42-428"><a href="#cb42-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-431"><a href="#cb42-431" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-432"><a href="#cb42-432" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-433"><a href="#cb42-433" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numpy_kde(x, means, widths):</span>
<span id="cb42-434"><a href="#cb42-434" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> (np.exp( <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> ((x <span class="op">-</span> means) <span class="op">/</span> widths)<span class="op">**</span><span class="dv">2</span> ) <span class="op">/</span> widths).mean()</span>
<span id="cb42-435"><a href="#cb42-435" aria-hidden="true" tabindex="-1"></a>    <span class="co"># .mean() already divides by n</span></span>
<span id="cb42-436"><a href="#cb42-436" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc <span class="op">/</span> SQRT_2PI</span>
<span id="cb42-437"><a href="#cb42-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-438"><a href="#cb42-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-441"><a href="#cb42-441" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-442"><a href="#cb42-442" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-443"><a href="#cb42-443" aria-hidden="true" tabindex="-1"></a>numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-444"><a href="#cb42-444" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-445"><a href="#cb42-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-448"><a href="#cb42-448" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-449"><a href="#cb42-449" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-450"><a href="#cb42-450" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-451"><a href="#cb42-451" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-452"><a href="#cb42-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-453"><a href="#cb42-453" aria-hidden="true" tabindex="-1"></a>Why is NumPy as fast as it is?  In this case, it is because the Anaconda build of NumPy uses MKL to accelerate (with SIMD and threads) many of the individial ufuncs, so it is only when Numba can combine all the operations together that the speed boost emerges.</span>
<span id="cb42-454"><a href="#cb42-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-455"><a href="#cb42-455" aria-hidden="true" tabindex="-1"></a>Incidentally, although we wrote out the iteration for <span class="in">`kde`</span> as a for loop to highlight what was going on, you still get the benefit of SIMD in Numba when compiling array expressions.  We could have compiled <span class="in">`numpy_kde`</span> directly:</span>
<span id="cb42-456"><a href="#cb42-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-459"><a href="#cb42-459" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-460"><a href="#cb42-460" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-461"><a href="#cb42-461" aria-hidden="true" tabindex="-1"></a>numba_numpy_kde <span class="op">=</span> jit(nopython<span class="op">=</span><span class="va">True</span>, error_model<span class="op">=</span><span class="st">'numpy'</span>, fastmath<span class="op">=</span><span class="va">True</span>)(numpy_kde)</span>
<span id="cb42-462"><a href="#cb42-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-463"><a href="#cb42-463" aria-hidden="true" tabindex="-1"></a>numba_numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-464"><a href="#cb42-464" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-465"><a href="#cb42-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-468"><a href="#cb42-468" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-469"><a href="#cb42-469" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: subslide}</span></span>
<span id="cb42-470"><a href="#cb42-470" aria-hidden="true" tabindex="-1"></a>find_instr(numba_numpy_kde, keyword<span class="op">=</span><span class="st">'subp'</span>)</span>
<span id="cb42-471"><a href="#cb42-471" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'---'</span>)</span>
<span id="cb42-472"><a href="#cb42-472" aria-hidden="true" tabindex="-1"></a>find_instr(numba_numpy_kde, keyword<span class="op">=</span><span class="st">'svml'</span>)</span>
<span id="cb42-473"><a href="#cb42-473" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-474"><a href="#cb42-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-475"><a href="#cb42-475" aria-hidden="true" tabindex="-1"></a>And it is nearly as fast as our manual looping version, and 2x faster than NumPy alone:</span>
<span id="cb42-476"><a href="#cb42-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-479"><a href="#cb42-479" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb42-480"><a href="#cb42-480" aria-hidden="true" tabindex="-1"></a><span class="co">#| slideshow: {slide_type: fragment}</span></span>
<span id="cb42-481"><a href="#cb42-481" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-482"><a href="#cb42-482" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numba_numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-483"><a href="#cb42-483" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_kde(<span class="fl">0.4</span>, means, widths)</span>
<span id="cb42-484"><a href="#cb42-484" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>